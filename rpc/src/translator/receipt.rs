use anyhow::Result;
use serde::{Deserialize, Serialize};
use tracing::debug;

use crate::stellar::types::GetTransactionResponse;

/// EVM-formatted transaction receipt.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct EvmTransactionReceipt {
    /// Transaction hash
    pub transaction_hash: String,
    /// Transaction index within the block
    pub transaction_index: String,
    /// Block hash
    pub block_hash: String,
    /// Block number
    pub block_number: String,
    /// Sender address
    pub from: String,
    /// Recipient address (null for contract creation)
    pub to: Option<String>,
    /// Cumulative gas used
    pub cumulative_gas_used: String,
    /// Gas used by this transaction
    pub gas_used: String,
    /// Effective gas price
    pub effective_gas_price: String,
    /// Contract address (if contract creation)
    pub contract_address: Option<String>,
    /// Logs generated by this transaction
    pub logs: Vec<EvmLog>,
    /// Logs bloom filter
    pub logs_bloom: String,
    /// Transaction status (1 = success, 0 = failure)
    pub status: String,
    /// Transaction type
    #[serde(rename = "type")]
    pub tx_type: String,
}

/// EVM-formatted log entry.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct EvmLog {
    /// Address that generated the log
    pub address: String,
    /// Indexed topics
    pub topics: Vec<String>,
    /// Non-indexed data
    pub data: String,
    /// Block number
    pub block_number: String,
    /// Transaction hash
    pub transaction_hash: String,
    /// Transaction index
    pub transaction_index: String,
    /// Block hash
    pub block_hash: String,
    /// Log index within the block
    pub log_index: String,
    /// Whether this log was removed (always false for finalized)
    pub removed: bool,
}

/// EVM-formatted transaction object.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct EvmTransaction {
    /// Transaction hash
    pub hash: String,
    /// Nonce
    pub nonce: String,
    /// Block hash
    pub block_hash: String,
    /// Block number
    pub block_number: String,
    /// Transaction index
    pub transaction_index: String,
    /// From address
    pub from: String,
    /// To address
    pub to: Option<String>,
    /// Value in wei
    pub value: String,
    /// Gas price
    pub gas_price: String,
    /// Gas limit
    pub gas: String,
    /// Input data
    pub input: String,
    /// V signature value
    pub v: String,
    /// R signature value
    pub r: String,
    /// S signature value
    pub s: String,
    /// Transaction type
    #[serde(rename = "type")]
    pub tx_type: String,
}

/// Build an EVM transaction receipt from a Stellar transaction response.
pub fn build_receipt_from_stellar(
    tx_response: &GetTransactionResponse,
    tx_hash_hex: &str,
    from_address: &str,
    to_address: Option<&str>,
    contract_address: Option<&str>,
) -> Result<EvmTransactionReceipt> {
    let status = match tx_response.status.as_str() {
        "SUCCESS" => "0x1".to_string(),
        "FAILED" => "0x0".to_string(),
        _ => "0x0".to_string(),
    };

    let block_number = tx_response
        .ledger
        .map(|l| format!("0x{:x}", l))
        .unwrap_or_else(|| "0x0".to_string());

    // Generate a deterministic block hash from ledger number
    let ledger_num = tx_response.ledger.unwrap_or(0);
    let block_hash = format!("0x{:064x}", ledger_num);

    // Estimate gas used from Soroban resource consumption
    // Default to a reasonable gas amount
    let gas_used = "0x5208"; // 21000 (standard transfer gas)

    let receipt = EvmTransactionReceipt {
        transaction_hash: ensure_0x_prefix(tx_hash_hex),
        transaction_index: "0x0".to_string(),
        block_hash,
        block_number,
        from: ensure_0x_prefix(from_address),
        to: to_address.map(ensure_0x_prefix),
        cumulative_gas_used: gas_used.to_string(),
        gas_used: gas_used.to_string(),
        effective_gas_price: "0x3b9aca00".to_string(), // 1 gwei
        contract_address: contract_address.map(ensure_0x_prefix),
        logs: Vec::new(), // TODO: parse events from result_meta_xdr
        logs_bloom: format!("0x{}", "0".repeat(512)),
        status,
        tx_type: "0x0".to_string(),
    };

    debug!("Built receipt for tx {}: status={}", tx_hash_hex, receipt.status);
    Ok(receipt)
}

/// Build an EVM transaction object from a Stellar transaction.
pub fn build_transaction_from_stellar(
    tx_response: &GetTransactionResponse,
    tx_hash_hex: &str,
    from_address: &str,
    to_address: Option<&str>,
) -> Result<EvmTransaction> {
    let block_number = tx_response
        .ledger
        .map(|l| format!("0x{:x}", l))
        .unwrap_or_else(|| "0x0".to_string());

    let ledger_num = tx_response.ledger.unwrap_or(0);
    let block_hash = format!("0x{:064x}", ledger_num);

    Ok(EvmTransaction {
        hash: ensure_0x_prefix(tx_hash_hex),
        nonce: "0x0".to_string(),
        block_hash,
        block_number,
        transaction_index: "0x0".to_string(),
        from: ensure_0x_prefix(from_address),
        to: to_address.map(ensure_0x_prefix),
        value: "0x0".to_string(),
        gas_price: "0x3b9aca00".to_string(),
        gas: "0x5208".to_string(),
        input: "0x".to_string(),
        v: "0x1b".to_string(),
        r: format!("0x{}", "0".repeat(64)),
        s: format!("0x{}", "0".repeat(64)),
        tx_type: "0x0".to_string(),
    })
}

/// Build a "pending" receipt for a transaction that was submitted but not yet confirmed.
pub fn build_pending_receipt(tx_hash_hex: &str) -> EvmTransactionReceipt {
    EvmTransactionReceipt {
        transaction_hash: ensure_0x_prefix(tx_hash_hex),
        transaction_index: "0x0".to_string(),
        block_hash: format!("0x{}", "0".repeat(64)),
        block_number: "0x0".to_string(),
        from: format!("0x{}", "0".repeat(40)),
        to: None,
        cumulative_gas_used: "0x0".to_string(),
        gas_used: "0x0".to_string(),
        effective_gas_price: "0x0".to_string(),
        contract_address: None,
        logs: Vec::new(),
        logs_bloom: format!("0x{}", "0".repeat(512)),
        status: "0x0".to_string(), // pending
        tx_type: "0x0".to_string(),
    }
}

/// Ensure a hex string has the 0x prefix.
fn ensure_0x_prefix(s: &str) -> String {
    if s.starts_with("0x") || s.starts_with("0X") {
        s.to_string()
    } else {
        format!("0x{}", s)
    }
}
