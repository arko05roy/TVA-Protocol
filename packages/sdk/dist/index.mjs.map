{"version":3,"sources":["../src/types/index.ts","../src/rpc/client.ts","../src/wallet/keys.ts","../src/wallet/signer.ts","../src/compiler/solang.ts","../src/contract/contract.ts","../src/utils/index.ts"],"names":["TVAErrorCode","path","generateMnemonic","validateMnemonic","secp256k12","hmac","sha256","keccak_256","lengthBytes","Keypair","fs","xdr"],"mappings":"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","file":"index.mjs","sourcesContent":["/**\n * TVA Protocol Type Definitions\n *\n * These types define the core abstractions for the TVA Protocol,\n * bridging EVM and Stellar/Soroban concepts.\n */\n\n// ============================================================================\n// Network Configuration\n// ============================================================================\n\nexport type NetworkType = 'testnet' | 'mainnet' | 'local';\n\nexport interface NetworkConfig {\n  /** Network identifier */\n  type: NetworkType;\n  /** TVA RPC endpoint URL */\n  rpcUrl: string;\n  /** Stellar Horizon URL */\n  horizonUrl: string;\n  /** Stellar Soroban RPC URL */\n  sorobanRpcUrl: string;\n  /** Network passphrase for Stellar */\n  networkPassphrase: string;\n  /** Chain ID for EVM compatibility */\n  chainId: number;\n  /** Native currency symbol (XLM) */\n  nativeCurrency: {\n    name: string;\n    symbol: string;\n    decimals: number;\n  };\n}\n\n/**\n * TVA Chain ID: \"TVA\\0\" = 0x54564100 = 1414676736\n */\nexport const TVA_CHAIN_ID = 1414676736;\n\nexport const NETWORKS: Record<NetworkType, NetworkConfig> = {\n  testnet: {\n    type: 'testnet',\n    rpcUrl: 'http://localhost:8545', // TVA RPC server\n    horizonUrl: 'https://horizon-testnet.stellar.org',\n    sorobanRpcUrl: 'https://soroban-testnet.stellar.org',\n    networkPassphrase: 'Test SDF Network ; September 2015',\n    chainId: TVA_CHAIN_ID,\n    nativeCurrency: {\n      name: 'Stellar Lumens',\n      symbol: 'XLM',\n      decimals: 7,\n    },\n  },\n  mainnet: {\n    type: 'mainnet',\n    rpcUrl: 'http://localhost:8545', // TVA RPC server (production URL TBD)\n    horizonUrl: 'https://horizon.stellar.org',\n    sorobanRpcUrl: 'https://soroban.stellar.org',\n    networkPassphrase: 'Public Global Stellar Network ; September 2015',\n    chainId: TVA_CHAIN_ID,\n    nativeCurrency: {\n      name: 'Stellar Lumens',\n      symbol: 'XLM',\n      decimals: 7,\n    },\n  },\n  local: {\n    type: 'local',\n    rpcUrl: 'http://localhost:8545',\n    horizonUrl: 'http://localhost:8000',\n    sorobanRpcUrl: 'http://localhost:8001',\n    networkPassphrase: 'Standalone Network ; February 2017',\n    chainId: TVA_CHAIN_ID,\n    nativeCurrency: {\n      name: 'Stellar Lumens',\n      symbol: 'XLM',\n      decimals: 7,\n    },\n  },\n};\n\n// ============================================================================\n// Address Types\n// ============================================================================\n\n/** 20-byte EVM-compatible address (hex string with 0x prefix) */\nexport type EvmAddress = `0x${string}`;\n\n/** 56-character Stellar G-address (Ed25519 public key) */\nexport type StellarAddress = `G${string}`;\n\n/** Soroban contract ID (C-address, 56 characters) */\nexport type SorobanContractId = `C${string}`;\n\n/** Generic address that could be EVM or Stellar format */\nexport type Address = EvmAddress | StellarAddress | SorobanContractId;\n\n/** Mapping between EVM and Stellar addresses */\nexport interface AddressMapping {\n  evmAddress: EvmAddress;\n  stellarAddress: StellarAddress;\n  registeredAt: number; // ledger sequence\n}\n\n// ============================================================================\n// Transaction Types\n// ============================================================================\n\nexport interface EvmTransaction {\n  from: EvmAddress;\n  to?: EvmAddress; // undefined for contract deployment\n  value: bigint;\n  data: string;\n  nonce: number;\n  gasLimit: bigint;\n  gasPrice: bigint;\n  chainId: number;\n}\n\nexport interface EvmTransactionReceipt {\n  transactionHash: string;\n  transactionIndex: number;\n  blockHash: string;\n  blockNumber: number;\n  from: EvmAddress;\n  to: EvmAddress | null;\n  contractAddress: EvmAddress | null;\n  cumulativeGasUsed: bigint;\n  gasUsed: bigint;\n  status: 0 | 1;\n  logs: EvmLog[];\n}\n\nexport interface EvmLog {\n  address: EvmAddress;\n  topics: string[];\n  data: string;\n  blockNumber: number;\n  transactionHash: string;\n  transactionIndex: number;\n  blockHash: string;\n  logIndex: number;\n  removed: boolean;\n}\n\nexport interface EvmBlock {\n  number: number;\n  hash: string;\n  parentHash: string;\n  timestamp: number;\n  miner: EvmAddress;\n  difficulty: bigint;\n  totalDifficulty: bigint;\n  gasLimit: bigint;\n  gasUsed: bigint;\n  transactions: string[];\n  transactionsRoot: string;\n  stateRoot: string;\n  receiptsRoot: string;\n  logsBloom: string;\n  nonce: string;\n  extraData: string;\n}\n\n// ============================================================================\n// Compilation Types\n// ============================================================================\n\nexport interface CompilerInput {\n  /** Solidity source code */\n  source: string;\n  /** Contract file name */\n  fileName: string;\n  /** Compiler optimization settings */\n  optimization?: {\n    enabled: boolean;\n    runs?: number;\n  };\n}\n\nexport interface CompilerOutput {\n  /** Compiled WASM binary (base64 encoded) */\n  wasm: string;\n  /** Contract ABI in JSON format */\n  abi: ContractABI;\n  /** Soroban contract spec entries */\n  spec: SorobanSpec[];\n  /** Compilation warnings */\n  warnings: string[];\n  /** Source map for debugging */\n  sourceMap?: string;\n}\n\nexport interface ContractABI {\n  /** Contract name */\n  name: string;\n  /** ABI entries */\n  functions: ABIFunction[];\n  events: ABIEvent[];\n  errors: ABIError[];\n}\n\nexport interface ABIFunction {\n  name: string;\n  inputs: ABIParameter[];\n  outputs: ABIParameter[];\n  stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';\n  type: 'function' | 'constructor' | 'fallback' | 'receive';\n}\n\nexport interface ABIEvent {\n  name: string;\n  inputs: ABIEventParameter[];\n  anonymous: boolean;\n}\n\nexport interface ABIParameter {\n  name: string;\n  type: string;\n  internalType?: string;\n  components?: ABIParameter[];\n}\n\nexport interface ABIEventParameter extends ABIParameter {\n  indexed: boolean;\n}\n\nexport interface ABIError {\n  name: string;\n  inputs: ABIParameter[];\n}\n\nexport interface SorobanSpec {\n  type: 'function' | 'struct' | 'union' | 'enum' | 'error';\n  name: string;\n  doc?: string;\n  inputs?: { name: string; type: ScValType }[];\n  outputs?: ScValType[];\n}\n\n// ============================================================================\n// Soroban-Specific Types\n// ============================================================================\n\nexport type ScValType =\n  | 'bool'\n  | 'void'\n  | 'error'\n  | 'u32'\n  | 'i32'\n  | 'u64'\n  | 'i64'\n  | 'timepoint'\n  | 'duration'\n  | 'u128'\n  | 'i128'\n  | 'u256'\n  | 'i256'\n  | 'bytes'\n  | 'string'\n  | 'symbol'\n  | 'address'\n  | { vec: ScValType }\n  | { map: { key: ScValType; value: ScValType } }\n  | { option: ScValType }\n  | { result: { ok: ScValType; err: ScValType } }\n  | { tuple: ScValType[] }\n  | { bytesN: number }\n  | { struct: string }\n  | { union: string }\n  | { enum: string };\n\nexport type StorageType = 'temporary' | 'instance' | 'persistent';\n\nexport interface StorageEntry {\n  key: string;\n  value: unknown;\n  type: StorageType;\n  ttl: number; // ledger sequence when entry expires\n}\n\n// ============================================================================\n// Contract Interaction Types\n// ============================================================================\n\nexport interface DeploymentConfig {\n  /** Compiled WASM binary (base64) */\n  wasm: string;\n  /** Constructor arguments */\n  constructorArgs?: unknown[];\n  /** Initial salt for address derivation */\n  salt?: string;\n  /** Network to deploy to */\n  network: NetworkType;\n}\n\nexport interface DeploymentResult {\n  /** Soroban contract ID */\n  contractId: SorobanContractId;\n  /** EVM-compatible contract address */\n  evmAddress: EvmAddress;\n  /** Deployment transaction hash (Stellar format) */\n  stellarTxHash: string;\n  /** Deployment transaction hash (EVM format) */\n  evmTxHash: string;\n  /** Ledger sequence of deployment */\n  ledgerSequence: number;\n}\n\nexport interface ContractCallConfig {\n  /** Contract address (EVM or Soroban format) */\n  contractAddress: Address;\n  /** Function name to call */\n  functionName: string;\n  /** Function arguments */\n  args?: unknown[];\n  /** Caller address */\n  from?: Address;\n}\n\nexport interface ContractCallResult<T = unknown> {\n  /** Return value from the contract */\n  result: T;\n  /** Gas/resource consumption */\n  gasUsed: bigint;\n  /** Events emitted during call */\n  events: EvmLog[];\n  /** Whether the call was a simulation (view) or on-chain */\n  simulated: boolean;\n}\n\n// ============================================================================\n// Wallet Types\n// ============================================================================\n\nexport interface KeyPair {\n  /** secp256k1 private key for EVM signing */\n  evmPrivateKey: string;\n  /** secp256k1 public key (uncompressed, 65 bytes) */\n  evmPublicKey: string;\n  /** Ed25519 secret key for Stellar signing */\n  stellarSecretKey: string;\n  /** Ed25519 public key for Stellar */\n  stellarPublicKey: string;\n}\n\nexport interface Account {\n  /** EVM-format address */\n  evmAddress: EvmAddress;\n  /** Stellar G-address */\n  stellarAddress: StellarAddress;\n  /** Whether this account is registered in the AccountRegistry */\n  isRegistered: boolean;\n  /** Account sequence number (Stellar) */\n  sequenceNumber?: string;\n  /** Account nonce (EVM) */\n  nonce?: number;\n}\n\nexport interface Balance {\n  /** Native XLM balance (in stroops, 1 XLM = 10^7 stroops) */\n  xlm: bigint;\n  /** Native XLM balance formatted (7 decimals) */\n  xlmFormatted: string;\n  /** Token balances keyed by contract address */\n  tokens: Map<Address, TokenBalance>;\n}\n\nexport interface TokenBalance {\n  /** Token contract address */\n  address: Address;\n  /** Token symbol */\n  symbol: string;\n  /** Token decimals */\n  decimals: number;\n  /** Raw balance */\n  balance: bigint;\n  /** Formatted balance */\n  balanceFormatted: string;\n}\n\n// ============================================================================\n// Error Types\n// ============================================================================\n\nexport class TVAError extends Error {\n  constructor(\n    message: string,\n    public code: TVAErrorCode,\n    public details?: Record<string, unknown>\n  ) {\n    super(message);\n    this.name = 'TVAError';\n  }\n}\n\nexport enum TVAErrorCode {\n  // Compilation errors (1xxx)\n  COMPILATION_FAILED = 1001,\n  SOLANG_NOT_FOUND = 1002,\n  INVALID_SOURCE = 1003,\n\n  // Network errors (2xxx)\n  NETWORK_ERROR = 2001,\n  RPC_ERROR = 2002,\n  TIMEOUT = 2003,\n\n  // Transaction errors (3xxx)\n  TRANSACTION_FAILED = 3001,\n  INSUFFICIENT_BALANCE = 3002,\n  INVALID_NONCE = 3003,\n  GAS_ESTIMATION_FAILED = 3004,\n\n  // Contract errors (4xxx)\n  CONTRACT_NOT_FOUND = 4001,\n  CONTRACT_REVERT = 4002,\n  INVALID_ARGUMENTS = 4003,\n\n  // Account errors (5xxx)\n  ACCOUNT_NOT_FOUND = 5001,\n  ACCOUNT_NOT_REGISTERED = 5002,\n  INVALID_SIGNATURE = 5003,\n\n  // Storage errors (6xxx)\n  STATE_ARCHIVED = 6001,\n  TTL_EXPIRED = 6002,\n  RESTORATION_FAILED = 6003,\n}\n","/**\n * TVA Protocol RPC Client\n *\n * Communicates with the TVA RPC server which translates\n * Ethereum JSON-RPC calls to Stellar/Soroban operations.\n */\n\nimport type {\n  EvmAddress,\n  EvmTransactionReceipt,\n  EvmBlock,\n  EvmLog,\n  NetworkType,\n  NetworkConfig,\n} from '../types/index.js';\nimport { NETWORKS, TVAError, TVAErrorCode } from '../types/index.js';\n\n/**\n * JSON-RPC request structure\n */\ninterface JsonRpcRequest {\n  jsonrpc: '2.0';\n  id: number;\n  method: string;\n  params: unknown[];\n}\n\n/**\n * JSON-RPC response structure\n */\ninterface JsonRpcResponse<T = unknown> {\n  jsonrpc: '2.0';\n  id: number;\n  result?: T;\n  error?: {\n    code: number;\n    message: string;\n    data?: unknown;\n  };\n}\n\n/**\n * RPC Client options\n */\nexport interface RpcClientOptions {\n  /** RPC endpoint URL */\n  url?: string;\n  /** Network type (uses pre-configured URL if not providing custom URL) */\n  network?: NetworkType;\n  /** Request timeout in milliseconds */\n  timeout?: number;\n  /** Custom headers for requests */\n  headers?: Record<string, string>;\n}\n\n/**\n * TVA RPC Client\n *\n * Provides type-safe access to the TVA JSON-RPC API.\n */\nexport class RpcClient {\n  private url: string;\n  private timeout: number;\n  private headers: Record<string, string>;\n  private requestId: number = 0;\n  public readonly network: NetworkConfig;\n\n  constructor(options: RpcClientOptions = {}) {\n    const networkType = options.network || 'testnet';\n    this.network = NETWORKS[networkType];\n    this.url = options.url || this.network.rpcUrl;\n    this.timeout = options.timeout || 30000;\n    this.headers = {\n      'Content-Type': 'application/json',\n      ...options.headers,\n    };\n  }\n\n  /**\n   * Makes a JSON-RPC request to the TVA RPC server\n   */\n  private async request<T>(method: string, params: unknown[] = []): Promise<T> {\n    const id = ++this.requestId;\n\n    const body: JsonRpcRequest = {\n      jsonrpc: '2.0',\n      id,\n      method,\n      params,\n    };\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n    try {\n      const response = await fetch(this.url, {\n        method: 'POST',\n        headers: this.headers,\n        body: JSON.stringify(body),\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new TVAError(\n          `HTTP error: ${response.status} ${response.statusText}`,\n          TVAErrorCode.RPC_ERROR,\n          { status: response.status }\n        );\n      }\n\n      const json = (await response.json()) as JsonRpcResponse<T>;\n\n      if (json.error) {\n        throw new TVAError(\n          json.error.message,\n          TVAErrorCode.RPC_ERROR,\n          { code: json.error.code, data: json.error.data }\n        );\n      }\n\n      return json.result as T;\n    } catch (error) {\n      clearTimeout(timeoutId);\n\n      if (error instanceof TVAError) {\n        throw error;\n      }\n\n      if ((error as Error).name === 'AbortError') {\n        throw new TVAError(\n          'Request timeout',\n          TVAErrorCode.TIMEOUT,\n          { timeout: this.timeout }\n        );\n      }\n\n      throw new TVAError(\n        `Network error: ${(error as Error).message}`,\n        TVAErrorCode.NETWORK_ERROR,\n        { originalError: error }\n      );\n    }\n  }\n\n  // ============================================================================\n  // Chain Methods\n  // ============================================================================\n\n  /**\n   * Returns the chain ID of the TVA network\n   */\n  async getChainId(): Promise<number> {\n    const result = await this.request<string>('eth_chainId');\n    return parseInt(result, 16);\n  }\n\n  /**\n   * Returns the network version\n   */\n  async getNetworkVersion(): Promise<string> {\n    return this.request<string>('net_version');\n  }\n\n  /**\n   * Returns the client version\n   */\n  async getClientVersion(): Promise<string> {\n    return this.request<string>('web3_clientVersion');\n  }\n\n  /**\n   * Returns the current gas price in wei\n   */\n  async getGasPrice(): Promise<bigint> {\n    const result = await this.request<string>('eth_gasPrice');\n    return BigInt(result);\n  }\n\n  // ============================================================================\n  // Block Methods\n  // ============================================================================\n\n  /**\n   * Returns the current block number (Stellar ledger sequence)\n   */\n  async getBlockNumber(): Promise<number> {\n    const result = await this.request<string>('eth_blockNumber');\n    return parseInt(result, 16);\n  }\n\n  /**\n   * Returns a block by number\n   */\n  async getBlockByNumber(\n    blockNumber: number | 'latest' | 'earliest' | 'pending',\n    includeTransactions: boolean = false\n  ): Promise<EvmBlock | null> {\n    const blockParam = typeof blockNumber === 'number'\n      ? `0x${blockNumber.toString(16)}`\n      : blockNumber;\n\n    return this.request<EvmBlock | null>('eth_getBlockByNumber', [\n      blockParam,\n      includeTransactions,\n    ]);\n  }\n\n  /**\n   * Returns a block by hash\n   */\n  async getBlockByHash(\n    blockHash: string,\n    includeTransactions: boolean = false\n  ): Promise<EvmBlock | null> {\n    return this.request<EvmBlock | null>('eth_getBlockByHash', [\n      blockHash,\n      includeTransactions,\n    ]);\n  }\n\n  // ============================================================================\n  // Account Methods\n  // ============================================================================\n\n  /**\n   * Returns the balance of an account in wei (XLM converted to 18 decimals)\n   */\n  async getBalance(\n    address: EvmAddress,\n    blockNumber: number | 'latest' = 'latest'\n  ): Promise<bigint> {\n    const blockParam = typeof blockNumber === 'number'\n      ? `0x${blockNumber.toString(16)}`\n      : blockNumber;\n\n    const result = await this.request<string>('eth_getBalance', [\n      address,\n      blockParam,\n    ]);\n    return BigInt(result);\n  }\n\n  /**\n   * Returns the transaction count (nonce) of an account\n   */\n  async getTransactionCount(\n    address: EvmAddress,\n    blockNumber: number | 'latest' | 'pending' = 'latest'\n  ): Promise<number> {\n    const blockParam = typeof blockNumber === 'number'\n      ? `0x${blockNumber.toString(16)}`\n      : blockNumber;\n\n    const result = await this.request<string>('eth_getTransactionCount', [\n      address,\n      blockParam,\n    ]);\n    return parseInt(result, 16);\n  }\n\n  /**\n   * Returns the code at a given address (contract WASM hash)\n   */\n  async getCode(\n    address: EvmAddress,\n    blockNumber: number | 'latest' = 'latest'\n  ): Promise<string> {\n    const blockParam = typeof blockNumber === 'number'\n      ? `0x${blockNumber.toString(16)}`\n      : blockNumber;\n\n    return this.request<string>('eth_getCode', [address, blockParam]);\n  }\n\n  // ============================================================================\n  // Transaction Methods\n  // ============================================================================\n\n  /**\n   * Sends a signed raw transaction\n   */\n  async sendRawTransaction(signedTransaction: string): Promise<string> {\n    return this.request<string>('eth_sendRawTransaction', [signedTransaction]);\n  }\n\n  /**\n   * Returns a transaction by hash\n   */\n  async getTransactionByHash(txHash: string): Promise<any | null> {\n    return this.request<any>('eth_getTransactionByHash', [txHash]);\n  }\n\n  /**\n   * Returns a transaction receipt\n   */\n  async getTransactionReceipt(txHash: string): Promise<EvmTransactionReceipt | null> {\n    return this.request<EvmTransactionReceipt | null>('eth_getTransactionReceipt', [txHash]);\n  }\n\n  /**\n   * Executes a call without creating a transaction (read-only)\n   */\n  async call(\n    transaction: {\n      from?: EvmAddress;\n      to: EvmAddress;\n      data?: string;\n      value?: string;\n      gas?: string;\n      gasPrice?: string;\n    },\n    blockNumber: number | 'latest' = 'latest'\n  ): Promise<string> {\n    const blockParam = typeof blockNumber === 'number'\n      ? `0x${blockNumber.toString(16)}`\n      : blockNumber;\n\n    return this.request<string>('eth_call', [transaction, blockParam]);\n  }\n\n  /**\n   * Estimates gas for a transaction\n   */\n  async estimateGas(transaction: {\n    from?: EvmAddress;\n    to?: EvmAddress;\n    data?: string;\n    value?: string;\n  }): Promise<bigint> {\n    const result = await this.request<string>('eth_estimateGas', [transaction]);\n    return BigInt(result);\n  }\n\n  // ============================================================================\n  // Log Methods\n  // ============================================================================\n\n  /**\n   * Returns logs matching the given filter\n   */\n  async getLogs(filter: {\n    fromBlock?: number | 'latest' | 'earliest';\n    toBlock?: number | 'latest' | 'earliest';\n    address?: EvmAddress | EvmAddress[];\n    topics?: (string | string[] | null)[];\n    blockHash?: string;\n  }): Promise<EvmLog[]> {\n    const formattedFilter: Record<string, unknown> = {};\n\n    if (filter.fromBlock !== undefined) {\n      formattedFilter.fromBlock = typeof filter.fromBlock === 'number'\n        ? `0x${filter.fromBlock.toString(16)}`\n        : filter.fromBlock;\n    }\n\n    if (filter.toBlock !== undefined) {\n      formattedFilter.toBlock = typeof filter.toBlock === 'number'\n        ? `0x${filter.toBlock.toString(16)}`\n        : filter.toBlock;\n    }\n\n    if (filter.address) {\n      formattedFilter.address = filter.address;\n    }\n\n    if (filter.topics) {\n      formattedFilter.topics = filter.topics;\n    }\n\n    if (filter.blockHash) {\n      formattedFilter.blockHash = filter.blockHash;\n    }\n\n    return this.request<EvmLog[]>('eth_getLogs', [formattedFilter]);\n  }\n\n  // ============================================================================\n  // Utility Methods\n  // ============================================================================\n\n  /**\n   * Computes keccak256 hash\n   */\n  async sha3(data: string): Promise<string> {\n    return this.request<string>('web3_sha3', [data]);\n  }\n\n  /**\n   * Waits for a transaction to be mined\n   */\n  async waitForTransaction(\n    txHash: string,\n    confirmations: number = 1,\n    timeout: number = 60000\n  ): Promise<EvmTransactionReceipt> {\n    const startTime = Date.now();\n\n    while (Date.now() - startTime < timeout) {\n      const receipt = await this.getTransactionReceipt(txHash);\n\n      if (receipt) {\n        // Check confirmations\n        const currentBlock = await this.getBlockNumber();\n        const txBlock = receipt.blockNumber;\n        const currentConfirmations = currentBlock - txBlock + 1;\n\n        if (currentConfirmations >= confirmations) {\n          return receipt;\n        }\n      }\n\n      // Wait before polling again (Stellar has ~5s block time)\n      await new Promise((resolve) => setTimeout(resolve, 2000));\n    }\n\n    throw new TVAError(\n      `Transaction ${txHash} was not mined within ${timeout}ms`,\n      TVAErrorCode.TIMEOUT,\n      { txHash, timeout }\n    );\n  }\n\n  /**\n   * Checks if the RPC server is healthy\n   */\n  async isHealthy(): Promise<boolean> {\n    try {\n      await this.getChainId();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n\n/**\n * Creates an RPC client for the specified network\n */\nexport function createRpcClient(\n  networkOrUrl: NetworkType | string = 'testnet'\n): RpcClient {\n  if (networkOrUrl.startsWith('http')) {\n    return new RpcClient({ url: networkOrUrl });\n  }\n  return new RpcClient({ network: networkOrUrl as NetworkType });\n}\n","/**\n * TVA Protocol Key Management\n *\n * Handles the dual-key architecture required for TVA Protocol:\n * - secp256k1 keys for EVM compatibility (MetaMask signing)\n * - Ed25519 keys for Stellar transaction submission\n *\n * Keys are derived deterministically so users can recover both\n * key types from a single mnemonic phrase.\n */\n\nimport { Keypair, StrKey } from '@stellar/stellar-sdk';\nimport * as bip39 from 'bip39';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { keccak_256 } from '@noble/hashes/sha3';\nimport * as secp256k1 from '@noble/secp256k1';\nimport * as ed25519 from '@noble/ed25519';\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha512 } from '@noble/hashes/sha512';\nimport type { KeyPair, EvmAddress, StellarAddress } from '../types/index.js';\n\n// Enable synchronous methods for ed25519 (required for node.js)\ned25519.etc.sha512Sync = (...m) => sha512(ed25519.etc.concatBytes(...m));\n\n/**\n * Derives a secp256k1 key from seed using BIP32 derivation\n */\nfunction deriveSecp256k1KeyFromSeed(\n  seed: Uint8Array,\n  path: string\n): Uint8Array {\n  // Master key derivation for Bitcoin-style keys\n  const I = hmac(sha512, new TextEncoder().encode('Bitcoin seed'), seed);\n  let key = new Uint8Array(I.slice(0, 32));\n  let chainCode = new Uint8Array(I.slice(32));\n\n  // Parse path\n  const segments = path\n    .replace(/^m\\//, '')\n    .split('/')\n    .map((s) => {\n      const hardened = s.endsWith(\"'\");\n      const index = parseInt(s.replace(\"'\", ''), 10);\n      return { index, hardened };\n    });\n\n  for (const segment of segments) {\n    const indexBuffer = new Uint8Array(4);\n    const view = new DataView(indexBuffer.buffer);\n\n    let data: Uint8Array;\n    if (segment.hardened) {\n      const hardenedIndex = segment.index | 0x80000000;\n      view.setUint32(0, hardenedIndex, false);\n      data = new Uint8Array(1 + 32 + 4);\n      data[0] = 0x00;\n      data.set(key, 1);\n      data.set(indexBuffer, 33);\n    } else {\n      view.setUint32(0, segment.index, false);\n      const publicKey = secp256k1.getPublicKey(key, true);\n      data = new Uint8Array(33 + 4);\n      data.set(publicKey, 0);\n      data.set(indexBuffer, 33);\n    }\n\n    const I2 = hmac(sha512, chainCode, data);\n    const IL = new Uint8Array(I2.slice(0, 32));\n    chainCode = new Uint8Array(I2.slice(32));\n\n    // Child key = parse256(IL) + parent key (mod n)\n    const parentKeyBigInt = bytesToBigInt(key);\n    const ILBigInt = bytesToBigInt(IL);\n    const n = BigInt(\n      '0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141'\n    );\n    const childKeyBigInt = (ILBigInt + parentKeyBigInt) % n;\n    key = bigIntToBytes(childKeyBigInt, 32);\n  }\n\n  return key;\n}\n\nfunction bytesToBigInt(bytes: Uint8Array): bigint {\n  let result = BigInt(0);\n  for (let i = 0; i < bytes.length; i++) {\n    result = (result << BigInt(8)) | BigInt(bytes[i]);\n  }\n  return result;\n}\n\nfunction bigIntToBytes(value: bigint, length: number): Uint8Array<ArrayBuffer> {\n  const result = new Uint8Array(length);\n  let v = value;\n  for (let i = length - 1; i >= 0; i--) {\n    result[i] = Number(v & BigInt(0xff));\n    v = v >> BigInt(8);\n  }\n  return result;\n}\n\n/**\n * Converts a secp256k1 public key to an EVM address\n */\nexport function publicKeyToEvmAddress(publicKey: Uint8Array): EvmAddress {\n  // Remove the 0x04 prefix if present (uncompressed key marker)\n  const keyWithoutPrefix =\n    publicKey.length === 65 ? publicKey.slice(1) : publicKey;\n\n  // Keccak256 hash of the public key (x,y coordinates)\n  const hash = keccak_256(keyWithoutPrefix);\n\n  // Take the last 20 bytes\n  const addressBytes = new Uint8Array(hash.slice(-20));\n\n  // Convert to hex string with 0x prefix\n  const hex = Array.from(addressBytes)\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('');\n\n  return `0x${hex}` as EvmAddress;\n}\n\n/**\n * Converts an Ed25519 public key to a Stellar G-address\n */\nexport function publicKeyToStellarAddress(\n  publicKey: Uint8Array\n): StellarAddress {\n  return StrKey.encodeEd25519PublicKey(Buffer.from(publicKey)) as StellarAddress;\n}\n\n/**\n * Converts an Ed25519 secret key to a Stellar S-address (secret)\n */\nexport function secretKeyToStellarSecret(secretKey: Uint8Array): string {\n  return StrKey.encodeEd25519SecretSeed(Buffer.from(secretKey));\n}\n\n/**\n * Generates a new mnemonic phrase\n */\nexport function generateMnemonic(strength: 128 | 256 = 256): string {\n  return bip39.generateMnemonic(strength);\n}\n\n/**\n * Validates a mnemonic phrase\n */\nexport function validateMnemonic(mnemonic: string): boolean {\n  return bip39.validateMnemonic(mnemonic);\n}\n\n/**\n * Derives a full TVA key pair from a mnemonic phrase\n * This creates both the EVM (secp256k1) and Stellar (Ed25519) key pairs\n */\nexport async function deriveKeyPairFromMnemonic(\n  mnemonic: string,\n  accountIndex: number = 0\n): Promise<KeyPair> {\n  if (!validateMnemonic(mnemonic)) {\n    throw new Error('Invalid mnemonic phrase');\n  }\n\n  // Generate seed from mnemonic\n  const seed = await bip39.mnemonicToSeed(mnemonic);\n  const seedArray = new Uint8Array(seed);\n\n  // Derive secp256k1 key for EVM\n  const evmPath = `m/44'/60'/0'/0/${accountIndex}`;\n  const evmPrivateKey = deriveSecp256k1KeyFromSeed(seedArray, evmPath);\n  const evmPublicKey = secp256k1.getPublicKey(evmPrivateKey, false); // uncompressed\n\n  // Derive Ed25519 key for Stellar\n  // Use a deterministic derivation from the EVM private key to ensure\n  // users can always recover their Stellar key from their EVM key\n  const stellarSeed = sha256(\n    new Uint8Array([\n      ...new TextEncoder().encode('TVA-STELLAR-KEY'),\n      ...evmPrivateKey,\n    ])\n  );\n  const stellarKeypair = Keypair.fromRawEd25519Seed(Buffer.from(stellarSeed));\n\n  return {\n    evmPrivateKey: `0x${Buffer.from(evmPrivateKey).toString('hex')}`,\n    evmPublicKey: `0x${Buffer.from(evmPublicKey).toString('hex')}`,\n    stellarSecretKey: stellarKeypair.secret(),\n    stellarPublicKey: stellarKeypair.publicKey(),\n  };\n}\n\n/**\n * Derives a key pair from an existing EVM private key\n * Useful for importing existing Ethereum wallets\n */\nexport function deriveKeyPairFromEvmPrivateKey(\n  evmPrivateKey: string\n): KeyPair {\n  // Remove 0x prefix if present\n  const privateKeyHex = evmPrivateKey.replace(/^0x/, '');\n  const privateKeyBytes = Buffer.from(privateKeyHex, 'hex');\n\n  if (privateKeyBytes.length !== 32) {\n    throw new Error('Invalid private key length');\n  }\n\n  // Get EVM public key\n  const evmPublicKey = secp256k1.getPublicKey(privateKeyBytes, false);\n\n  // Derive Stellar key deterministically from EVM private key\n  const stellarSeed = sha256(\n    new Uint8Array([\n      ...new TextEncoder().encode('TVA-STELLAR-KEY'),\n      ...privateKeyBytes,\n    ])\n  );\n  const stellarKeypair = Keypair.fromRawEd25519Seed(Buffer.from(stellarSeed));\n\n  return {\n    evmPrivateKey: `0x${privateKeyHex}`,\n    evmPublicKey: `0x${Buffer.from(evmPublicKey).toString('hex')}`,\n    stellarSecretKey: stellarKeypair.secret(),\n    stellarPublicKey: stellarKeypair.publicKey(),\n  };\n}\n\n/**\n * Creates a random key pair (for testing or new accounts)\n */\nexport function generateRandomKeyPair(): KeyPair {\n  const mnemonic = generateMnemonic();\n  // Use synchronous version for random generation\n  const seed = bip39.mnemonicToSeedSync(mnemonic);\n  const seedArray = new Uint8Array(seed);\n\n  const evmPath = `m/44'/60'/0'/0/0`;\n  const evmPrivateKey = deriveSecp256k1KeyFromSeed(seedArray, evmPath);\n  const evmPublicKey = secp256k1.getPublicKey(evmPrivateKey, false);\n\n  const stellarSeed = sha256(\n    new Uint8Array([\n      ...new TextEncoder().encode('TVA-STELLAR-KEY'),\n      ...evmPrivateKey,\n    ])\n  );\n  const stellarKeypair = Keypair.fromRawEd25519Seed(Buffer.from(stellarSeed));\n\n  return {\n    evmPrivateKey: `0x${Buffer.from(evmPrivateKey).toString('hex')}`,\n    evmPublicKey: `0x${Buffer.from(evmPublicKey).toString('hex')}`,\n    stellarSecretKey: stellarKeypair.secret(),\n    stellarPublicKey: stellarKeypair.publicKey(),\n  };\n}\n\n/**\n * Gets the EVM address from a key pair\n */\nexport function getEvmAddress(keyPair: KeyPair): EvmAddress {\n  const publicKeyBytes = Buffer.from(keyPair.evmPublicKey.replace(/^0x/, ''), 'hex');\n  return publicKeyToEvmAddress(publicKeyBytes);\n}\n\n/**\n * Gets the Stellar address from a key pair\n */\nexport function getStellarAddress(keyPair: KeyPair): StellarAddress {\n  return keyPair.stellarPublicKey as StellarAddress;\n}\n\n/**\n * Verifies that an EVM address matches a public key\n */\nexport function verifyEvmAddress(\n  address: EvmAddress,\n  publicKey: string\n): boolean {\n  const publicKeyBytes = Buffer.from(publicKey.replace(/^0x/, ''), 'hex');\n  const derivedAddress = publicKeyToEvmAddress(publicKeyBytes);\n  return derivedAddress.toLowerCase() === address.toLowerCase();\n}\n\n/**\n * Verifies that a Stellar address matches a public key\n */\nexport function verifyStellarAddress(\n  address: StellarAddress,\n  publicKey: string\n): boolean {\n  return address === publicKey;\n}\n","/**\n * TVA Protocol Transaction Signer\n *\n * Handles signing for both EVM-format and Stellar-format transactions.\n * This is critical for the TVA dual-key architecture where:\n * - Users sign with their EVM wallet (MetaMask)\n * - The signed transaction is translated and re-signed for Stellar submission\n */\n\nimport {\n  Keypair,\n  Transaction,\n  xdr,\n} from '@stellar/stellar-sdk';\nimport { keccak_256 } from '@noble/hashes/sha3';\nimport * as secp256k1 from '@noble/secp256k1';\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport type {\n  KeyPair,\n  EvmTransaction,\n  EvmAddress,\n  NetworkType,\n  NetworkConfig,\n} from '../types/index.js';\nimport { NETWORKS } from '../types/index.js';\nimport { getEvmAddress } from './keys.js';\n\n// RFC6979 deterministic k generation for secp256k1 signing\nsecp256k1.etc.hmacSha256Sync = (k, ...m) =>\n  hmac(sha256, k, secp256k1.etc.concatBytes(...m));\n\n/**\n * EVM Transaction Signer\n * Signs transactions using secp256k1 (Ethereum-compatible)\n */\nexport class EvmSigner {\n  private privateKey: Uint8Array;\n  public readonly address: EvmAddress;\n\n  constructor(keyPair: KeyPair) {\n    this.privateKey = Buffer.from(\n      keyPair.evmPrivateKey.replace(/^0x/, ''),\n      'hex'\n    );\n    this.address = getEvmAddress(keyPair);\n  }\n\n  /**\n   * Signs a message hash using secp256k1\n   */\n  signHash(hash: Uint8Array): { r: string; s: string; v: number } {\n    const signature = secp256k1.sign(hash, this.privateKey);\n    const r = signature.r.toString(16).padStart(64, '0');\n    const s = signature.s.toString(16).padStart(64, '0');\n\n    // Calculate recovery id (v)\n    // For EIP-155 transactions: v = chainId * 2 + 35 + recovery_id\n    // For legacy: v = 27 + recovery_id\n    const v = signature.recovery + 27;\n\n    return { r: `0x${r}`, s: `0x${s}`, v };\n  }\n\n  /**\n   * Signs a personal message (EIP-191)\n   */\n  signMessage(message: string): string {\n    const messageBytes = new TextEncoder().encode(message);\n    const prefix = new TextEncoder().encode(\n      `\\x19Ethereum Signed Message:\\n${messageBytes.length}`\n    );\n    const prefixedMessage = new Uint8Array([...prefix, ...messageBytes]);\n    const hash = keccak_256(prefixedMessage);\n\n    const { r, s, v } = this.signHash(hash);\n    return `${r}${s.slice(2)}${v.toString(16).padStart(2, '0')}`;\n  }\n\n  /**\n   * Signs typed data (EIP-712)\n   */\n  signTypedData(\n    domain: Record<string, unknown>,\n    types: Record<string, Array<{ name: string; type: string }>>,\n    value: Record<string, unknown>\n  ): string {\n    // Simplified EIP-712 implementation\n    // In production, use a full implementation from ethers.js\n    const domainSeparator = this.hashStruct('EIP712Domain', domain, {\n      EIP712Domain: [\n        { name: 'name', type: 'string' },\n        { name: 'version', type: 'string' },\n        { name: 'chainId', type: 'uint256' },\n        { name: 'verifyingContract', type: 'address' },\n      ],\n    });\n\n    const primaryType = Object.keys(types).find((t) => t !== 'EIP712Domain');\n    if (!primaryType) {\n      throw new Error('No primary type found');\n    }\n\n    const structHash = this.hashStruct(primaryType, value, types);\n\n    const messageHash = keccak_256(\n      new Uint8Array([0x19, 0x01, ...domainSeparator, ...structHash])\n    );\n\n    const { r, s, v } = this.signHash(messageHash);\n    return `${r}${s.slice(2)}${v.toString(16).padStart(2, '0')}`;\n  }\n\n  private hashStruct(\n    typeName: string,\n    data: Record<string, unknown>,\n    types: Record<string, Array<{ name: string; type: string }>>\n  ): Uint8Array {\n    const typeHash = keccak_256(\n      new TextEncoder().encode(this.encodeType(typeName, types))\n    );\n    const encodedData = this.encodeData(typeName, data, types);\n    return keccak_256(new Uint8Array([...typeHash, ...encodedData]));\n  }\n\n  private encodeType(\n    primaryType: string,\n    types: Record<string, Array<{ name: string; type: string }>>\n  ): string {\n    const fields = types[primaryType];\n    if (!fields) {\n      return primaryType;\n    }\n\n    const fieldDefs = fields.map((f) => `${f.type} ${f.name}`).join(',');\n    return `${primaryType}(${fieldDefs})`;\n  }\n\n  private encodeData(\n    typeName: string,\n    data: Record<string, unknown>,\n    types: Record<string, Array<{ name: string; type: string }>>\n  ): Uint8Array {\n    const fields = types[typeName];\n    if (!fields) {\n      throw new Error(`Unknown type: ${typeName}`);\n    }\n\n    const parts: Uint8Array[] = [];\n\n    for (const field of fields) {\n      const value = data[field.name];\n      parts.push(this.encodeValue(field.type, value, types));\n    }\n\n    return new Uint8Array(parts.flatMap((p) => [...p]));\n  }\n\n  private encodeValue(\n    type: string,\n    value: unknown,\n    types: Record<string, Array<{ name: string; type: string }>>\n  ): Uint8Array {\n    if (type === 'string') {\n      return keccak_256(new TextEncoder().encode(value as string));\n    }\n\n    if (type === 'bytes') {\n      const bytes = Buffer.from((value as string).replace(/^0x/, ''), 'hex');\n      return keccak_256(bytes);\n    }\n\n    if (type === 'address') {\n      const addr = (value as string).replace(/^0x/, '').toLowerCase();\n      const padded = new Uint8Array(32);\n      const addrBytes = Buffer.from(addr, 'hex');\n      padded.set(addrBytes, 32 - addrBytes.length);\n      return padded;\n    }\n\n    if (type.startsWith('uint') || type.startsWith('int')) {\n      const num = BigInt(value as string | number | bigint);\n      const bytes = new Uint8Array(32);\n      let val = num;\n      for (let i = 31; i >= 0; i--) {\n        bytes[i] = Number(val & BigInt(0xff));\n        val = val >> BigInt(8);\n      }\n      return bytes;\n    }\n\n    if (type === 'bool') {\n      const bytes = new Uint8Array(32);\n      bytes[31] = value ? 1 : 0;\n      return bytes;\n    }\n\n    if (types[type]) {\n      return this.hashStruct(type, value as Record<string, unknown>, types);\n    }\n\n    throw new Error(`Unsupported type: ${type}`);\n  }\n\n  /**\n   * Signs an EVM transaction and returns the signed raw transaction\n   */\n  signTransaction(tx: EvmTransaction): string {\n    // Encode transaction for signing (RLP encoding)\n    const encodedTx = this.rlpEncodeTransaction(tx);\n    const hash = keccak_256(encodedTx);\n\n    const signature = this.signHash(hash);\n\n    // Calculate v with EIP-155 chain ID\n    const v = tx.chainId * 2 + 35 + (signature.v - 27);\n\n    // Encode signed transaction\n    return this.rlpEncodeSignedTransaction(tx, {\n      r: signature.r,\n      s: signature.s,\n      v,\n    });\n  }\n\n  private rlpEncodeTransaction(tx: EvmTransaction): Uint8Array {\n    // Simplified RLP encoding for EIP-155 transactions\n    // Format: [nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0]\n    const items: (Uint8Array | string | number | bigint | null)[] = [\n      tx.nonce,\n      tx.gasPrice,\n      tx.gasLimit,\n      tx.to || '',\n      tx.value,\n      tx.data,\n      tx.chainId,\n      0,\n      0,\n    ];\n\n    return this.rlpEncode(items);\n  }\n\n  private rlpEncodeSignedTransaction(\n    tx: EvmTransaction,\n    sig: { r: string; s: string; v: number }\n  ): string {\n    const items: (Uint8Array | string | number | bigint | null)[] = [\n      tx.nonce,\n      tx.gasPrice,\n      tx.gasLimit,\n      tx.to || '',\n      tx.value,\n      tx.data,\n      sig.v,\n      sig.r,\n      sig.s,\n    ];\n\n    const encoded = this.rlpEncode(items);\n    return '0x' + Buffer.from(encoded).toString('hex');\n  }\n\n  private rlpEncode(\n    input: (Uint8Array | string | number | bigint | null)[] | Uint8Array | string | number | bigint | null\n  ): Uint8Array {\n    if (Array.isArray(input)) {\n      const encodedItems = input.map((item) => this.rlpEncode(item));\n      const totalLength = encodedItems.reduce((sum, item) => sum + item.length, 0);\n      const flatItems = encodedItems.flatMap((item) => Array.from(item));\n\n      if (totalLength < 56) {\n        return new Uint8Array([0xc0 + totalLength, ...flatItems]);\n      } else {\n        const lengthBytes = this.encodeBigEndian(totalLength);\n        return new Uint8Array([\n          0xf7 + lengthBytes.length,\n          ...Array.from(lengthBytes),\n          ...flatItems,\n        ]);\n      }\n    }\n\n    const bytes = this.toBytes(input);\n\n    if (bytes.length === 1 && bytes[0] < 0x80) {\n      return bytes;\n    }\n\n    if (bytes.length < 56) {\n      return new Uint8Array([0x80 + bytes.length, ...Array.from(bytes)]);\n    }\n\n    const lengthBytes = this.encodeBigEndian(bytes.length);\n    return new Uint8Array([0xb7 + lengthBytes.length, ...Array.from(lengthBytes), ...Array.from(bytes)]);\n  }\n\n  private toBytes(\n    input: Uint8Array | string | number | bigint | null\n  ): Uint8Array {\n    if (input === null || input === '' || input === 0 || input === BigInt(0)) {\n      return new Uint8Array(0);\n    }\n\n    if (input instanceof Uint8Array) {\n      return input;\n    }\n\n    if (typeof input === 'string') {\n      if (input.startsWith('0x')) {\n        const hex = input.slice(2);\n        if (hex.length === 0) {\n          return new Uint8Array(0);\n        }\n        return Buffer.from(hex.padStart(hex.length + (hex.length % 2), '0'), 'hex');\n      }\n      return new TextEncoder().encode(input);\n    }\n\n    if (typeof input === 'number' || typeof input === 'bigint') {\n      return this.encodeBigEndian(input);\n    }\n\n    throw new Error(`Cannot encode: ${input}`);\n  }\n\n  private encodeBigEndian(value: number | bigint): Uint8Array {\n    if (value === 0 || value === BigInt(0)) {\n      return new Uint8Array(0);\n    }\n\n    const bytes: number[] = [];\n    let v = BigInt(value);\n\n    while (v > 0) {\n      bytes.unshift(Number(v & BigInt(0xff)));\n      v = v >> BigInt(8);\n    }\n\n    return new Uint8Array(bytes);\n  }\n}\n\n/**\n * Stellar Transaction Signer\n * Signs transactions using Ed25519 (Stellar-compatible)\n */\nexport class StellarSigner {\n  private keypair: Keypair;\n  public readonly publicKey: string;\n\n  constructor(keyPair: KeyPair) {\n    this.keypair = Keypair.fromSecret(keyPair.stellarSecretKey);\n    this.publicKey = this.keypair.publicKey();\n  }\n\n  /**\n   * Signs a Stellar transaction\n   */\n  signTransaction(\n    transaction: Transaction,\n    _networkPassphrase?: string\n  ): Transaction {\n    transaction.sign(this.keypair);\n    return transaction;\n  }\n\n  /**\n   * Signs arbitrary data\n   */\n  signData(data: Uint8Array): Uint8Array {\n    return this.keypair.sign(Buffer.from(data));\n  }\n\n  /**\n   * Verifies a signature\n   */\n  verifySignature(data: Uint8Array, signature: Uint8Array): boolean {\n    return this.keypair.verify(Buffer.from(data), Buffer.from(signature));\n  }\n\n  /**\n   * Signs a Soroban authorization entry\n   */\n  signAuthEntry(\n    entry: xdr.SorobanAuthorizationEntry,\n    networkPassphrase: string,\n    validUntilLedger: number\n  ): xdr.SorobanAuthorizationEntry {\n    // Clone the entry to avoid mutation\n    const signedEntry = xdr.SorobanAuthorizationEntry.fromXDR(entry.toXDR());\n\n    // Get the credentials\n    const credentials = signedEntry.credentials();\n\n    if (credentials.switch().value === 0) {\n      // Source account credentials - no signature needed\n      return signedEntry;\n    }\n\n    // Address credentials - need to sign\n    const addressCredentials = credentials.address();\n\n    // Create the preimage for signing\n    const preimage = xdr.HashIdPreimage.envelopeTypeSorobanAuthorization(\n      new xdr.HashIdPreimageSorobanAuthorization({\n        networkId: Buffer.from(sha256(new TextEncoder().encode(networkPassphrase))),\n        nonce: addressCredentials.nonce(),\n        signatureExpirationLedger: validUntilLedger,\n        invocation: signedEntry.rootInvocation(),\n      })\n    );\n\n    const preimageHash = sha256(preimage.toXDR());\n    const signature = this.keypair.sign(Buffer.from(preimageHash));\n\n    // Set the signature\n    const newCredentials = new xdr.SorobanAddressCredentials({\n      address: addressCredentials.address(),\n      nonce: addressCredentials.nonce(),\n      signatureExpirationLedger: validUntilLedger,\n      signature: xdr.ScVal.scvVec([\n        xdr.ScVal.scvMap([\n          new xdr.ScMapEntry({\n            key: xdr.ScVal.scvSymbol('public_key'),\n            val: xdr.ScVal.scvBytes(this.keypair.rawPublicKey()),\n          }),\n          new xdr.ScMapEntry({\n            key: xdr.ScVal.scvSymbol('signature'),\n            val: xdr.ScVal.scvBytes(signature),\n          }),\n        ]),\n      ]),\n    });\n\n    signedEntry.credentials(xdr.SorobanCredentials.sorobanCredentialsAddress(newCredentials));\n\n    return signedEntry;\n  }\n}\n\n/**\n * Combined TVA Signer that handles both EVM and Stellar signing\n */\nexport class TVASigner {\n  public readonly evmSigner: EvmSigner;\n  public readonly stellarSigner: StellarSigner;\n  public readonly keyPair: KeyPair;\n  public readonly network: NetworkConfig;\n\n  constructor(keyPair: KeyPair, network: NetworkType = 'testnet') {\n    this.keyPair = keyPair;\n    this.network = NETWORKS[network];\n    this.evmSigner = new EvmSigner(keyPair);\n    this.stellarSigner = new StellarSigner(keyPair);\n  }\n\n  get evmAddress(): EvmAddress {\n    return this.evmSigner.address;\n  }\n\n  get stellarAddress(): string {\n    return this.stellarSigner.publicKey;\n  }\n\n  /**\n   * Signs an EVM-format transaction\n   */\n  signEvmTransaction(tx: EvmTransaction): string {\n    return this.evmSigner.signTransaction(tx);\n  }\n\n  /**\n   * Signs a Stellar transaction\n   */\n  signStellarTransaction(transaction: Transaction): Transaction {\n    return this.stellarSigner.signTransaction(\n      transaction,\n      this.network.networkPassphrase\n    );\n  }\n\n  /**\n   * Signs a personal message (for wallet connect / dapp signatures)\n   */\n  signMessage(message: string): string {\n    return this.evmSigner.signMessage(message);\n  }\n}\n","/**\n * TVA Protocol Solang Compiler Wrapper\n *\n * Wraps the Solang compiler binary for compiling Solidity to Soroban WASM.\n * Handles binary discovery, invocation, output parsing, and error translation.\n */\n\nimport { spawn } from 'child_process';\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\nimport * as os from 'os';\nimport type {\n  CompilerInput,\n  CompilerOutput,\n  ContractABI,\n  ABIFunction,\n  ABIEvent,\n  ABIError,\n  SorobanSpec,\n} from '../types/index.js';\nimport { TVAError, TVAErrorCode } from '../types/index.js';\n\n/**\n * Paths where Solang binary might be located\n */\nconst SOLANG_BINARY_PATHS = [\n  // User-specified path via environment variable\n  process.env.TVA_SOLANG_PATH,\n  // Local project path\n  path.join(process.cwd(), 'solang'),\n  path.join(process.cwd(), 'bin', 'solang'),\n  // TVA tooling path\n  path.join(process.cwd(), 'tooling', 'solang', 'target', 'release', 'solang'),\n  // Global installations\n  '/usr/local/bin/solang',\n  '/usr/bin/solang',\n  // Homebrew (macOS)\n  '/opt/homebrew/bin/solang',\n  // Cargo installation\n  path.join(os.homedir(), '.cargo', 'bin', 'solang'),\n].filter(Boolean) as string[];\n\n/**\n * Finds the Solang binary\n */\nasync function findSolangBinary(): Promise<string> {\n  for (const binaryPath of SOLANG_BINARY_PATHS) {\n    try {\n      await fs.access(binaryPath, fs.constants.X_OK);\n      return binaryPath;\n    } catch {\n      // Binary not found at this path, try next\n    }\n  }\n\n  throw new TVAError(\n    'Solang compiler not found. Please install Solang or set TVA_SOLANG_PATH environment variable.',\n    TVAErrorCode.SOLANG_NOT_FOUND,\n    {\n      searchedPaths: SOLANG_BINARY_PATHS,\n    }\n  );\n}\n\n/**\n * Compiler options\n */\nexport interface SolangCompilerOptions {\n  /** Path to Solang binary (auto-detected if not specified) */\n  solangPath?: string;\n  /** Optimization level (0-3) */\n  optimizationLevel?: number;\n  /** Output directory for compiled artifacts */\n  outputDir?: string;\n  /** Additional Solang flags */\n  additionalFlags?: string[];\n  /** Import paths for Solidity imports */\n  importPaths?: string[];\n}\n\n/**\n * Compiled contract artifact\n */\nexport interface CompiledContract {\n  /** Contract name */\n  name: string;\n  /** WASM binary (as Buffer) */\n  wasm: Buffer;\n  /** Contract ABI */\n  abi: ContractABI;\n  /** Soroban spec entries */\n  spec: SorobanSpec[];\n  /** Source file path */\n  sourcePath: string;\n  /** Compilation warnings */\n  warnings: string[];\n}\n\n/**\n * Solang compiler wrapper\n */\nexport class SolangCompiler {\n  private solangPath: string | null = null;\n  private options: SolangCompilerOptions;\n\n  constructor(options: SolangCompilerOptions = {}) {\n    this.options = {\n      optimizationLevel: 2,\n      ...options,\n    };\n  }\n\n  /**\n   * Initializes the compiler by finding the Solang binary\n   */\n  async initialize(): Promise<void> {\n    if (this.options.solangPath) {\n      this.solangPath = this.options.solangPath;\n    } else {\n      this.solangPath = await findSolangBinary();\n    }\n  }\n\n  /**\n   * Gets the Solang version\n   */\n  async getVersion(): Promise<string> {\n    if (!this.solangPath) {\n      await this.initialize();\n    }\n\n    return new Promise((resolve, reject) => {\n      const proc = spawn(this.solangPath!, ['--version']);\n      let output = '';\n\n      proc.stdout.on('data', (data) => {\n        output += data.toString();\n      });\n\n      proc.on('close', (code) => {\n        if (code === 0) {\n          // Parse version from output like \"solang version v0.3.3\"\n          const match = output.match(/solang version v?([\\d.]+)/i);\n          resolve(match ? match[1] : output.trim());\n        } else {\n          reject(new Error('Failed to get Solang version'));\n        }\n      });\n    });\n  }\n\n  /**\n   * Compiles a Solidity source file to Soroban WASM\n   */\n  async compile(input: CompilerInput): Promise<CompilerOutput> {\n    if (!this.solangPath) {\n      await this.initialize();\n    }\n\n    // Create temporary directory for compilation\n    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'tva-compile-'));\n    const sourceFile = path.join(tempDir, input.fileName);\n    const outputDir = this.options.outputDir || tempDir;\n\n    try {\n      // Write source file\n      await fs.writeFile(sourceFile, input.source);\n\n      // Build Solang command\n      const args = [\n        'compile',\n        sourceFile,\n        '--target', 'soroban',\n        '-o', outputDir,\n      ];\n\n      // Add optimization level\n      if (this.options.optimizationLevel !== undefined) {\n        args.push(`-O${this.options.optimizationLevel}`);\n      }\n\n      // Add import paths\n      if (this.options.importPaths) {\n        for (const importPath of this.options.importPaths) {\n          args.push('-I', importPath);\n        }\n      }\n\n      // Add additional flags\n      if (this.options.additionalFlags) {\n        args.push(...this.options.additionalFlags);\n      }\n\n      // Run Solang\n      const result = await this.runSolang(args);\n\n      if (result.exitCode !== 0 && !result.stdout.includes('.wasm')) {\n        throw new TVAError(\n          `Compilation failed: ${result.stderr || result.stdout}`,\n          TVAErrorCode.COMPILATION_FAILED,\n          {\n            stdout: result.stdout,\n            stderr: result.stderr,\n            exitCode: result.exitCode,\n          }\n        );\n      }\n\n      // Find output files\n      const files = await fs.readdir(outputDir);\n      const wasmFile = files.find((f) => f.endsWith('.wasm'));\n      const abiFile = files.find((f) => f.endsWith('.abi') || f.endsWith('.json'));\n\n      if (!wasmFile) {\n        throw new TVAError(\n          'No WASM file produced by compilation',\n          TVAErrorCode.COMPILATION_FAILED,\n          {\n            outputFiles: files,\n            stdout: result.stdout,\n            stderr: result.stderr,\n          }\n        );\n      }\n\n      // Read WASM file\n      const wasmPath = path.join(outputDir, wasmFile);\n      const wasmBuffer = await fs.readFile(wasmPath);\n\n      // Parse ABI if available\n      let abi: ContractABI = {\n        name: input.fileName.replace('.sol', ''),\n        functions: [],\n        events: [],\n        errors: [],\n      };\n\n      if (abiFile) {\n        const abiPath = path.join(outputDir, abiFile);\n        const abiContent = await fs.readFile(abiPath, 'utf-8');\n        abi = this.parseABI(abiContent, input.fileName);\n      }\n\n      // Extract spec from WASM (custom section)\n      const spec = this.extractSorobanSpec(wasmBuffer);\n\n      // Parse warnings from output\n      const warnings = this.parseWarnings(result.stdout + result.stderr);\n\n      return {\n        wasm: wasmBuffer.toString('base64'),\n        abi,\n        spec,\n        warnings,\n      };\n    } finally {\n      // Clean up temp directory if we created one\n      if (!this.options.outputDir) {\n        await fs.rm(tempDir, { recursive: true, force: true }).catch(() => {});\n      }\n    }\n  }\n\n  /**\n   * Compiles a Solidity source file and returns detailed artifacts\n   */\n  async compileFile(filePath: string): Promise<CompiledContract[]> {\n    const source = await fs.readFile(filePath, 'utf-8');\n    const fileName = path.basename(filePath);\n\n    const output = await this.compile({\n      source,\n      fileName,\n    });\n\n    // For now, return a single contract\n    // In the future, handle multiple contracts per file\n    return [\n      {\n        name: output.abi.name,\n        wasm: Buffer.from(output.wasm, 'base64'),\n        abi: output.abi,\n        spec: output.spec,\n        sourcePath: filePath,\n        warnings: output.warnings,\n      },\n    ];\n  }\n\n  /**\n   * Compiles multiple Solidity files\n   */\n  async compileFiles(filePaths: string[]): Promise<CompiledContract[]> {\n    const results: CompiledContract[] = [];\n\n    for (const filePath of filePaths) {\n      const contracts = await this.compileFile(filePath);\n      results.push(...contracts);\n    }\n\n    return results;\n  }\n\n  /**\n   * Runs Solang with the given arguments\n   */\n  private runSolang(args: string[]): Promise<{\n    exitCode: number;\n    stdout: string;\n    stderr: string;\n  }> {\n    return new Promise((resolve) => {\n      const proc = spawn(this.solangPath!, args);\n      let stdout = '';\n      let stderr = '';\n\n      proc.stdout.on('data', (data) => {\n        stdout += data.toString();\n      });\n\n      proc.stderr.on('data', (data) => {\n        stderr += data.toString();\n      });\n\n      proc.on('close', (exitCode) => {\n        resolve({\n          exitCode: exitCode ?? 1,\n          stdout,\n          stderr,\n        });\n      });\n\n      proc.on('error', (error) => {\n        resolve({\n          exitCode: 1,\n          stdout,\n          stderr: stderr + error.message,\n        });\n      });\n    });\n  }\n\n  /**\n   * Parses Solang ABI output\n   */\n  private parseABI(abiContent: string, fileName: string): ContractABI {\n    try {\n      const parsed = JSON.parse(abiContent);\n\n      // Handle both array format (standard) and object format (Solang)\n      const entries = Array.isArray(parsed) ? parsed : parsed.abi || [];\n\n      const functions: ABIFunction[] = [];\n      const events: ABIEvent[] = [];\n      const errors: ABIError[] = [];\n\n      for (const entry of entries) {\n        if (entry.type === 'function' || !entry.type) {\n          functions.push({\n            name: entry.name,\n            inputs: entry.inputs || [],\n            outputs: entry.outputs || [],\n            stateMutability: entry.stateMutability || 'nonpayable',\n            type: 'function',\n          });\n        } else if (entry.type === 'constructor') {\n          functions.push({\n            name: 'constructor',\n            inputs: entry.inputs || [],\n            outputs: [],\n            stateMutability: entry.stateMutability || 'nonpayable',\n            type: 'constructor',\n          });\n        } else if (entry.type === 'event') {\n          events.push({\n            name: entry.name,\n            inputs: entry.inputs || [],\n            anonymous: entry.anonymous || false,\n          });\n        } else if (entry.type === 'error') {\n          errors.push({\n            name: entry.name,\n            inputs: entry.inputs || [],\n          });\n        }\n      }\n\n      return {\n        name: parsed.name || fileName.replace('.sol', ''),\n        functions,\n        events,\n        errors,\n      };\n    } catch (error) {\n      // Return empty ABI on parse error\n      return {\n        name: fileName.replace('.sol', ''),\n        functions: [],\n        events: [],\n        errors: [],\n      };\n    }\n  }\n\n  /**\n   * Extracts Soroban spec from WASM custom section\n   */\n  private extractSorobanSpec(wasmBuffer: Buffer): SorobanSpec[] {\n    // Soroban stores contract spec in a custom section named \"contractspecv0\"\n    // For now, return empty array - full implementation requires WASM parsing\n    // This will be enhanced when we integrate with the Stellar SDK's spec extraction\n    try {\n      const specs: SorobanSpec[] = [];\n\n      // Simple WASM custom section parser\n      let offset = 8; // Skip magic number and version\n\n      while (offset < wasmBuffer.length) {\n        const sectionId = wasmBuffer[offset++];\n        const sectionSize = this.readLEB128(wasmBuffer, offset);\n        offset = sectionSize.offset;\n\n        if (sectionId === 0) {\n          // Custom section\n          const nameLen = this.readLEB128(wasmBuffer, offset);\n          offset = nameLen.offset;\n\n          const name = wasmBuffer.slice(offset, offset + nameLen.value).toString('utf-8');\n          offset += nameLen.value;\n\n          if (name === 'contractspecv0') {\n            // Found the spec section - parse it\n            // The spec is XDR encoded, so we'd need the Stellar SDK to decode it\n            // For now, just note that we found it\n            specs.push({\n              type: 'function',\n              name: '_spec_found',\n              doc: 'Soroban spec section found in WASM',\n            });\n          }\n        }\n\n        offset += sectionSize.value - (offset - sectionSize.offset);\n      }\n\n      return specs;\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Reads a LEB128 encoded integer from a buffer\n   */\n  private readLEB128(\n    buffer: Buffer,\n    offset: number\n  ): { value: number; offset: number } {\n    let result = 0;\n    let shift = 0;\n    let byte: number;\n\n    do {\n      byte = buffer[offset++];\n      result |= (byte & 0x7f) << shift;\n      shift += 7;\n    } while (byte & 0x80);\n\n    return { value: result, offset };\n  }\n\n  /**\n   * Parses compilation warnings from Solang output\n   */\n  private parseWarnings(output: string): string[] {\n    const warnings: string[] = [];\n    const lines = output.split('\\n');\n\n    for (const line of lines) {\n      if (line.includes('warning:') || line.includes('Warning:')) {\n        warnings.push(line.trim());\n      }\n    }\n\n    return warnings;\n  }\n}\n\n/**\n * Convenience function to compile a single file\n */\nexport async function compileSource(\n  source: string,\n  fileName: string = 'Contract.sol',\n  options?: SolangCompilerOptions\n): Promise<CompilerOutput> {\n  const compiler = new SolangCompiler(options);\n  return compiler.compile({ source, fileName });\n}\n\n/**\n * Convenience function to compile a file from disk\n */\nexport async function compileFile(\n  filePath: string,\n  options?: SolangCompilerOptions\n): Promise<CompiledContract[]> {\n  const compiler = new SolangCompiler(options);\n  return compiler.compileFile(filePath);\n}\n","/**\n * TVA Protocol Contract Interaction\n *\n * Provides high-level APIs for deploying and interacting with\n * Solidity contracts compiled to Soroban WASM.\n */\n\nimport {\n  Contract,\n  TransactionBuilder,\n  Operation,\n  xdr,\n  Address,\n  nativeToScVal,\n  scValToNative,\n  rpc,\n} from '@stellar/stellar-sdk';\nimport type {\n  ContractABI,\n  ABIFunction,\n  EvmAddress,\n  SorobanContractId,\n  NetworkType,\n  NetworkConfig,\n  DeploymentResult,\n  ContractCallResult,\n  EvmLog,\n} from '../types/index.js';\nimport { NETWORKS, TVAError, TVAErrorCode } from '../types/index.js';\nimport type { TVASigner } from '../wallet/signer.js';\nimport type { CompiledContract } from '../compiler/solang.js';\nimport { keccak_256 } from '@noble/hashes/sha3';\n\n/**\n * Converts an EVM address to a Soroban contract ID format\n * This is deterministic based on the deployment parameters\n */\nexport function evmAddressToContractId(evmAddress: EvmAddress): SorobanContractId {\n  // The contract ID is derived from the deployment transaction\n  // For now, return a placeholder - real implementation needs AccountRegistry lookup\n  const addressBytes = Buffer.from(evmAddress.slice(2), 'hex');\n  // Pad to 32 bytes and encode as Soroban C-address\n  const padded = Buffer.alloc(32);\n  addressBytes.copy(padded, 12);\n\n  // This is a simplified version - real implementation uses Stellar's address encoding\n  const encoded = padded.toString('hex');\n  return `C${encoded.toUpperCase().slice(0, 55)}` as SorobanContractId;\n}\n\n/**\n * Converts a Soroban contract ID to an EVM address format\n */\nexport function contractIdToEvmAddress(contractId: SorobanContractId): EvmAddress {\n  // Extract bytes from contract ID and take last 20 bytes\n  // Real implementation needs proper C-address decoding\n  const hex = contractId.slice(1).toLowerCase();\n  const last40 = hex.slice(-40);\n  return `0x${last40}` as EvmAddress;\n}\n\n/**\n * Calculates the EVM function selector (first 4 bytes of keccak256 hash)\n */\nexport function getFunctionSelector(signature: string): string {\n  const hash = keccak_256(new TextEncoder().encode(signature));\n  return '0x' + Buffer.from(hash.slice(0, 4)).toString('hex');\n}\n\n/**\n * Gets the function signature from ABI\n */\nexport function getFunctionSignature(func: ABIFunction): string {\n  const inputTypes = func.inputs.map((i) => i.type).join(',');\n  return `${func.name}(${inputTypes})`;\n}\n\n/**\n * Encodes function call data in EVM ABI format\n */\nexport function encodeFunctionCall(\n  func: ABIFunction,\n  args: unknown[]\n): string {\n  const signature = getFunctionSignature(func);\n  const selector = getFunctionSelector(signature);\n\n  // Encode arguments (simplified - use ethers.js AbiCoder for full support)\n  const encodedArgs = encodeArguments(func.inputs, args);\n\n  return selector + encodedArgs.slice(2);\n}\n\n/**\n * Encodes arguments for ABI\n */\nfunction encodeArguments(\n  inputs: { name: string; type: string }[],\n  args: unknown[]\n): string {\n  const parts: string[] = [];\n\n  for (let i = 0; i < inputs.length; i++) {\n    const input = inputs[i];\n    const arg = args[i];\n    parts.push(encodeValue(input.type, arg));\n  }\n\n  return '0x' + parts.join('');\n}\n\n/**\n * Encodes a single value for ABI\n */\nfunction encodeValue(type: string, value: unknown): string {\n  // Handle basic types\n  if (type === 'address') {\n    const addr = (value as string).replace(/^0x/, '').toLowerCase();\n    return addr.padStart(64, '0');\n  }\n\n  if (type.startsWith('uint') || type.startsWith('int')) {\n    const num = BigInt(value as string | number | bigint);\n    const hex = num.toString(16);\n    return hex.padStart(64, '0');\n  }\n\n  if (type === 'bool') {\n    return (value ? '1' : '0').padStart(64, '0');\n  }\n\n  if (type === 'bytes32') {\n    const bytes = (value as string).replace(/^0x/, '');\n    return bytes.padEnd(64, '0');\n  }\n\n  if (type === 'string') {\n    const strBytes = new TextEncoder().encode(value as string);\n    const length = strBytes.length.toString(16).padStart(64, '0');\n    const data = Buffer.from(strBytes).toString('hex').padEnd(\n      Math.ceil(strBytes.length / 32) * 64,\n      '0'\n    );\n    // For dynamic types, we need offset + length + data\n    // Simplified: just encode inline for now\n    return length + data;\n  }\n\n  throw new Error(`Unsupported ABI type: ${type}`);\n}\n\n/**\n * Converts Solidity type to ScVal type\n */\nfunction solidityTypeToScVal(type: string, value: unknown): xdr.ScVal {\n  if (type === 'address') {\n    const addrStr = value as string;\n    // If it's a Stellar address (starts with G), use it directly\n    // Otherwise, convert from EVM address\n    if (addrStr.startsWith('G')) {\n      return Address.fromString(addrStr).toScVal();\n    }\n    // For EVM addresses, we'd need to look up the registry\n    // For now, create a bytes representation\n    return xdr.ScVal.scvBytes(Buffer.from(addrStr.replace(/^0x/, ''), 'hex'));\n  }\n\n  if (type === 'uint64' || type === 'uint') {\n    return nativeToScVal(BigInt(value as string | number), { type: 'u64' });\n  }\n\n  if (type === 'int64') {\n    return nativeToScVal(BigInt(value as string | number), { type: 'i64' });\n  }\n\n  if (type === 'uint128') {\n    return nativeToScVal(BigInt(value as string | number), { type: 'u128' });\n  }\n\n  if (type === 'int128') {\n    return nativeToScVal(BigInt(value as string | number), { type: 'i128' });\n  }\n\n  if (type === 'uint32') {\n    return nativeToScVal(Number(value), { type: 'u32' });\n  }\n\n  if (type === 'int32') {\n    return nativeToScVal(Number(value), { type: 'i32' });\n  }\n\n  if (type === 'bool') {\n    return nativeToScVal(Boolean(value), { type: 'bool' });\n  }\n\n  if (type === 'string') {\n    return nativeToScVal(String(value), { type: 'string' });\n  }\n\n  if (type === 'bytes' || type.startsWith('bytes')) {\n    const bytes = Buffer.from((value as string).replace(/^0x/, ''), 'hex');\n    return xdr.ScVal.scvBytes(bytes);\n  }\n\n  // Default to string conversion\n  return nativeToScVal(String(value), { type: 'string' });\n}\n\n/**\n * TVA Contract instance for interacting with deployed contracts\n */\nexport class TVAContract {\n  public readonly contractId: SorobanContractId;\n  public readonly evmAddress: EvmAddress;\n  public readonly abi: ContractABI;\n  private readonly network: NetworkConfig;\n  private readonly sorobanClient: rpc.Server;\n\n  constructor(\n    contractId: SorobanContractId,\n    abi: ContractABI,\n    network: NetworkType = 'testnet'\n  ) {\n    this.contractId = contractId;\n    this.evmAddress = contractIdToEvmAddress(contractId);\n    this.abi = abi;\n    this.network = NETWORKS[network];\n    this.sorobanClient = new rpc.Server(this.network.sorobanRpcUrl);\n  }\n\n  /**\n   * Gets a function from the ABI by name\n   */\n  getFunction(name: string): ABIFunction | undefined {\n    return this.abi.functions.find((f) => f.name === name);\n  }\n\n  /**\n   * Simulates a contract call (read-only, doesn't submit transaction)\n   */\n  async call<T = unknown>(\n    functionName: string,\n    args: unknown[] = [],\n    signer?: TVASigner\n  ): Promise<ContractCallResult<T>> {\n    const func = this.getFunction(functionName);\n    if (!func) {\n      throw new TVAError(\n        `Function ${functionName} not found in contract ABI`,\n        TVAErrorCode.INVALID_ARGUMENTS,\n        { availableFunctions: this.abi.functions.map((f) => f.name) }\n      );\n    }\n\n    // Convert arguments to ScVal format\n    const scArgs = func.inputs.map((input, i) =>\n      solidityTypeToScVal(input.type, args[i])\n    );\n\n    // Build the contract call\n    const contract = new Contract(this.contractId);\n    const operation = contract.call(functionName, ...scArgs);\n\n    // If no signer, we need a source account for simulation\n    // Use a placeholder public key - simulation doesn't require real signature\n    const sourcePublicKey = signer?.stellarAddress ||\n      'GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF';\n\n    // Get account info\n    let account;\n    try {\n      account = await this.sorobanClient.getAccount(sourcePublicKey);\n    } catch {\n      // For simulation, we can use a mock account\n      account = {\n        accountId: () => sourcePublicKey,\n        sequenceNumber: () => '0',\n        incrementSequenceNumber: () => {},\n      };\n    }\n\n    // Build transaction\n    const transaction = new TransactionBuilder(account as any, {\n      fee: '100',\n      networkPassphrase: this.network.networkPassphrase,\n    })\n      .addOperation(operation)\n      .setTimeout(30)\n      .build();\n\n    // Simulate the transaction\n    const simulation = await this.sorobanClient.simulateTransaction(transaction);\n\n    if (rpc.Api.isSimulationError(simulation)) {\n      throw new TVAError(\n        `Contract call simulation failed: ${simulation.error}`,\n        TVAErrorCode.CONTRACT_REVERT,\n        { error: simulation.error }\n      );\n    }\n\n    // Extract result\n    let result: T = undefined as T;\n    if (rpc.Api.isSimulationSuccess(simulation) && simulation.result) {\n      result = scValToNative(simulation.result.retval) as T;\n    }\n\n    // Extract events/logs\n    const events: EvmLog[] = [];\n    // Events would be extracted from simulation.events when available\n\n    return {\n      result,\n      gasUsed: BigInt(simulation.minResourceFee || 0),\n      events,\n      simulated: true,\n    };\n  }\n\n  /**\n   * Sends a transaction to the contract (state-changing)\n   */\n  async send(\n    functionName: string,\n    args: unknown[] = [],\n    signer: TVASigner\n  ): Promise<ContractCallResult<unknown>> {\n    const func = this.getFunction(functionName);\n    if (!func) {\n      throw new TVAError(\n        `Function ${functionName} not found in contract ABI`,\n        TVAErrorCode.INVALID_ARGUMENTS,\n        { availableFunctions: this.abi.functions.map((f) => f.name) }\n      );\n    }\n\n    // Convert arguments to ScVal format\n    const scArgs = func.inputs.map((input, i) =>\n      solidityTypeToScVal(input.type, args[i])\n    );\n\n    // Build the contract call\n    const contract = new Contract(this.contractId);\n    const operation = contract.call(functionName, ...scArgs);\n\n    // Get account\n    const account = await this.sorobanClient.getAccount(signer.stellarAddress);\n\n    // Build transaction\n    let transaction = new TransactionBuilder(account, {\n      fee: '100',\n      networkPassphrase: this.network.networkPassphrase,\n    })\n      .addOperation(operation)\n      .setTimeout(30)\n      .build();\n\n    // Simulate to get resource requirements\n    const simulation = await this.sorobanClient.simulateTransaction(transaction);\n\n    if (rpc.Api.isSimulationError(simulation)) {\n      throw new TVAError(\n        `Transaction simulation failed: ${simulation.error}`,\n        TVAErrorCode.CONTRACT_REVERT,\n        { error: simulation.error }\n      );\n    }\n\n    // Prepare transaction with simulation results\n    transaction = rpc.assembleTransaction(\n      transaction,\n      simulation\n    ).build();\n\n    // Sign with Stellar key\n    const signedTx = signer.signStellarTransaction(transaction);\n\n    // Submit transaction\n    const sendResponse = await this.sorobanClient.sendTransaction(signedTx);\n\n    if (sendResponse.status === 'ERROR') {\n      throw new TVAError(\n        `Transaction submission failed`,\n        TVAErrorCode.TRANSACTION_FAILED,\n        { response: sendResponse }\n      );\n    }\n\n    // Wait for confirmation\n    let txResult = await this.sorobanClient.getTransaction(sendResponse.hash);\n    while (txResult.status === 'NOT_FOUND') {\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n      txResult = await this.sorobanClient.getTransaction(sendResponse.hash);\n    }\n\n    if (txResult.status !== 'SUCCESS') {\n      throw new TVAError(\n        `Transaction failed: ${txResult.status}`,\n        TVAErrorCode.TRANSACTION_FAILED,\n        { result: txResult }\n      );\n    }\n\n    // Extract return value\n    let returnValue: unknown = undefined;\n    if ('returnValue' in txResult && txResult.returnValue) {\n      returnValue = scValToNative(txResult.returnValue as xdr.ScVal);\n    }\n\n    return {\n      result: returnValue,\n      gasUsed: BigInt(0), // Fee info not directly available in GetTransactionResponse\n      events: [], // TODO: Parse events from result\n      simulated: false,\n    };\n  }\n\n  /**\n   * Creates a typed contract interface with methods matching the ABI\n   */\n  connect(signer: TVASigner): TypedContract {\n    return new TypedContract(this, signer);\n  }\n}\n\n/**\n * Typed contract wrapper that provides method-based access\n */\nexport class TypedContract {\n  private contract: TVAContract;\n  private signer: TVASigner;\n\n  constructor(contract: TVAContract, signer: TVASigner) {\n    this.contract = contract;\n    this.signer = signer;\n\n    // Create dynamic methods for each function in the ABI\n    for (const func of contract.abi.functions) {\n      if (func.type === 'constructor') continue;\n\n      const isView =\n        func.stateMutability === 'view' || func.stateMutability === 'pure';\n\n      (this as any)[func.name] = async (...args: unknown[]) => {\n        if (isView) {\n          return this.contract.call(func.name, args, this.signer);\n        } else {\n          return this.contract.send(func.name, args, this.signer);\n        }\n      };\n    }\n  }\n\n  /**\n   * Gets the underlying contract instance\n   */\n  getContract(): TVAContract {\n    return this.contract;\n  }\n}\n\n/**\n * Contract deployer for deploying new contracts\n */\nexport class ContractDeployer {\n  private network: NetworkConfig;\n  private sorobanClient: rpc.Server;\n\n  constructor(network: NetworkType = 'testnet') {\n    this.network = NETWORKS[network];\n    this.sorobanClient = new rpc.Server(this.network.sorobanRpcUrl);\n  }\n\n  /**\n   * Deploys a compiled contract to the network\n   */\n  async deploy(\n    contract: CompiledContract,\n    signer: TVASigner,\n    constructorArgs: unknown[] = []\n  ): Promise<DeploymentResult> {\n    // Step 1: Upload the WASM\n    const wasmHash = await this.uploadWasm(contract.wasm, signer);\n\n    // Step 2: Create the contract instance\n    const contractId = await this.createInstance(\n      wasmHash,\n      signer,\n      contract.abi,\n      constructorArgs\n    );\n\n    // Calculate EVM address from contract ID\n    const evmAddress = contractIdToEvmAddress(contractId);\n\n    // Get deployment transaction info\n    const ledgerSequence = await this.getCurrentLedgerSequence();\n\n    return {\n      contractId,\n      evmAddress,\n      stellarTxHash: wasmHash, // Using wasm hash as placeholder\n      evmTxHash: `0x${wasmHash.slice(0, 64)}`,\n      ledgerSequence,\n    };\n  }\n\n  /**\n   * Uploads WASM to the network\n   */\n  private async uploadWasm(wasm: Buffer, signer: TVASigner): Promise<string> {\n    // Get account\n    const account = await this.sorobanClient.getAccount(signer.stellarAddress);\n\n    // Build upload transaction\n    const uploadOp = Operation.uploadContractWasm({ wasm });\n\n    let transaction = new TransactionBuilder(account, {\n      fee: '100',\n      networkPassphrase: this.network.networkPassphrase,\n    })\n      .addOperation(uploadOp)\n      .setTimeout(30)\n      .build();\n\n    // Simulate\n    const simulation = await this.sorobanClient.simulateTransaction(transaction);\n\n    if (rpc.Api.isSimulationError(simulation)) {\n      throw new TVAError(\n        `WASM upload simulation failed: ${simulation.error}`,\n        TVAErrorCode.COMPILATION_FAILED,\n        { error: simulation.error }\n      );\n    }\n\n    // Prepare and sign\n    transaction = rpc.assembleTransaction(transaction, simulation).build();\n    const signedTx = signer.signStellarTransaction(transaction);\n\n    // Submit\n    const response = await this.sorobanClient.sendTransaction(signedTx);\n\n    // Wait for confirmation\n    let result: any = response;\n    while (result.status === 'PENDING' || result.status === 'NOT_FOUND') {\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n      result = await this.sorobanClient.getTransaction(response.hash);\n    }\n\n    if (result.status !== 'SUCCESS') {\n      throw new TVAError(\n        `WASM upload failed: ${result.status}`,\n        TVAErrorCode.COMPILATION_FAILED,\n        { result }\n      );\n    }\n\n    // Extract WASM hash from result\n    // The hash is returned in the transaction result\n    const wasmHash = keccak_256(wasm);\n    return Buffer.from(wasmHash).toString('hex');\n  }\n\n  /**\n   * Creates a contract instance from uploaded WASM\n   */\n  private async createInstance(\n    wasmHash: string,\n    signer: TVASigner,\n    _abi: ContractABI,\n    _constructorArgs: unknown[]\n  ): Promise<SorobanContractId> {\n    // Get account\n    const account = await this.sorobanClient.getAccount(signer.stellarAddress);\n\n    // Build create contract operation\n    const createOp = Operation.createCustomContract({\n      address: Address.fromString(signer.stellarAddress),\n      wasmHash: Buffer.from(wasmHash, 'hex'),\n      salt: Buffer.from(keccak_256(new TextEncoder().encode(Date.now().toString()))),\n    });\n\n    let transaction = new TransactionBuilder(account, {\n      fee: '100',\n      networkPassphrase: this.network.networkPassphrase,\n    })\n      .addOperation(createOp)\n      .setTimeout(30)\n      .build();\n\n    // Simulate\n    const simulation = await this.sorobanClient.simulateTransaction(transaction);\n\n    if (rpc.Api.isSimulationError(simulation)) {\n      throw new TVAError(\n        `Contract creation simulation failed: ${simulation.error}`,\n        TVAErrorCode.COMPILATION_FAILED,\n        { error: simulation.error }\n      );\n    }\n\n    // Prepare and sign\n    transaction = rpc.assembleTransaction(transaction, simulation).build();\n    const signedTx = signer.signStellarTransaction(transaction);\n\n    // Submit\n    const response = await this.sorobanClient.sendTransaction(signedTx);\n\n    // Wait for confirmation\n    let result: any = response;\n    while (result.status === 'PENDING' || result.status === 'NOT_FOUND') {\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n      result = await this.sorobanClient.getTransaction(response.hash);\n    }\n\n    if (result.status !== 'SUCCESS') {\n      throw new TVAError(\n        `Contract creation failed: ${result.status}`,\n        TVAErrorCode.COMPILATION_FAILED,\n        { result }\n      );\n    }\n\n    // Extract contract ID from result\n    // The contract ID is derived from the creator address and salt\n    const contractIdBytes = keccak_256(\n      new Uint8Array([\n        ...new TextEncoder().encode(signer.stellarAddress),\n        ...Buffer.from(wasmHash, 'hex'),\n      ])\n    );\n\n    return `C${Buffer.from(contractIdBytes).toString('hex').toUpperCase().slice(0, 55)}` as SorobanContractId;\n  }\n\n  /**\n   * Gets the current ledger sequence number\n   */\n  private async getCurrentLedgerSequence(): Promise<number> {\n    const latestLedger = await this.sorobanClient.getLatestLedger();\n    return latestLedger.sequence;\n  }\n}\n","/**\n * TVA Protocol Utility Functions\n */\n\nimport { keccak_256 } from '@noble/hashes/sha3';\n\n/**\n * Converts a hex string to Uint8Array\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  const cleanHex = hex.replace(/^0x/, '');\n  const bytes = new Uint8Array(cleanHex.length / 2);\n  for (let i = 0; i < bytes.length; i++) {\n    bytes[i] = parseInt(cleanHex.substr(i * 2, 2), 16);\n  }\n  return bytes;\n}\n\n/**\n * Converts Uint8Array to hex string\n */\nexport function bytesToHex(bytes: Uint8Array, prefix = true): string {\n  const hex = Array.from(bytes)\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('');\n  return prefix ? `0x${hex}` : hex;\n}\n\n/**\n * Computes keccak256 hash\n */\nexport function keccak256(data: Uint8Array | string): string {\n  const input = typeof data === 'string' ? hexToBytes(data) : data;\n  const hash = keccak_256(input);\n  return bytesToHex(hash);\n}\n\n/**\n * Pads a hex string to a specific length\n */\nexport function padHex(hex: string, length: number, side: 'left' | 'right' = 'left'): string {\n  const cleanHex = hex.replace(/^0x/, '');\n  const padded = side === 'left'\n    ? cleanHex.padStart(length, '0')\n    : cleanHex.padEnd(length, '0');\n  return `0x${padded}`;\n}\n\n/**\n * Formats a bigint as a decimal string with specified decimals\n */\nexport function formatUnits(value: bigint, decimals: number): string {\n  const negative = value < 0n;\n  const absValue = negative ? -value : value;\n\n  const str = absValue.toString().padStart(decimals + 1, '0');\n  const integerPart = str.slice(0, -decimals) || '0';\n  const decimalPart = str.slice(-decimals);\n\n  // Trim trailing zeros from decimal part\n  const trimmedDecimal = decimalPart.replace(/0+$/, '');\n\n  const result = trimmedDecimal ? `${integerPart}.${trimmedDecimal}` : integerPart;\n  return negative ? `-${result}` : result;\n}\n\n/**\n * Parses a decimal string to bigint with specified decimals\n */\nexport function parseUnits(value: string, decimals: number): bigint {\n  const negative = value.startsWith('-');\n  const cleanValue = negative ? value.slice(1) : value;\n\n  const [integerPart, decimalPart = ''] = cleanValue.split('.');\n\n  // Pad or truncate decimal part to match decimals\n  const paddedDecimal = decimalPart.padEnd(decimals, '0').slice(0, decimals);\n\n  const combined = integerPart + paddedDecimal;\n  const result = BigInt(combined);\n\n  return negative ? -result : result;\n}\n\n/**\n * Formats XLM (7 decimals) for display\n */\nexport function formatXlm(stroops: bigint): string {\n  return formatUnits(stroops, 7);\n}\n\n/**\n * Parses XLM string to stroops\n */\nexport function parseXlm(xlm: string): bigint {\n  return parseUnits(xlm, 7);\n}\n\n/**\n * Formats ETH-style value (18 decimals) for display\n */\nexport function formatEth(wei: bigint): string {\n  return formatUnits(wei, 18);\n}\n\n/**\n * Parses ETH string to wei\n */\nexport function parseEth(eth: string): bigint {\n  return parseUnits(eth, 18);\n}\n\n/**\n * Validates an EVM address format\n */\nexport function isValidEvmAddress(address: string): boolean {\n  return /^0x[0-9a-fA-F]{40}$/.test(address);\n}\n\n/**\n * Validates a Stellar G-address format\n */\nexport function isValidStellarAddress(address: string): boolean {\n  return /^G[A-Z2-7]{55}$/.test(address);\n}\n\n/**\n * Validates a Soroban C-address format\n */\nexport function isValidContractId(address: string): boolean {\n  return /^C[A-Z2-7]{55}$/.test(address);\n}\n\n/**\n * Checksums an EVM address (EIP-55)\n */\nexport function checksumAddress(address: string): string {\n  const addr = address.toLowerCase().replace(/^0x/, '');\n  const hash = keccak256(new TextEncoder().encode(addr)).replace(/^0x/, '');\n\n  let checksummed = '0x';\n  for (let i = 0; i < addr.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      checksummed += addr[i].toUpperCase();\n    } else {\n      checksummed += addr[i];\n    }\n  }\n\n  return checksummed;\n}\n\n/**\n * Validates a checksummed EVM address (EIP-55)\n */\nexport function isValidChecksumAddress(address: string): boolean {\n  if (!isValidEvmAddress(address)) return false;\n  return address === checksumAddress(address);\n}\n\n/**\n * Sleep for a specified number of milliseconds\n */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Retry a function with exponential backoff\n */\nexport async function retry<T>(\n  fn: () => Promise<T>,\n  options: {\n    maxRetries?: number;\n    initialDelay?: number;\n    maxDelay?: number;\n    shouldRetry?: (error: unknown) => boolean;\n  } = {}\n): Promise<T> {\n  const {\n    maxRetries = 3,\n    initialDelay = 1000,\n    maxDelay = 30000,\n    shouldRetry = () => true,\n  } = options;\n\n  let lastError: unknown;\n  let delay = initialDelay;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error;\n\n      if (attempt === maxRetries || !shouldRetry(error)) {\n        throw error;\n      }\n\n      await sleep(delay);\n      delay = Math.min(delay * 2, maxDelay);\n    }\n  }\n\n  throw lastError;\n}\n\n/**\n * Creates a deferred promise\n */\nexport function deferred<T>(): {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (error: unknown) => void;\n} {\n  let resolve!: (value: T) => void;\n  let reject!: (error: unknown) => void;\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise, resolve, reject };\n}\n\n/**\n * Chunks an array into smaller arrays\n */\nexport function chunk<T>(array: T[], size: number): T[][] {\n  const chunks: T[][] = [];\n  for (let i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n"]}