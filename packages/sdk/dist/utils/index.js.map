{"version":3,"sources":["../../src/utils/index.ts"],"names":["keccak_256"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * TVA Protocol Utility Functions\n */\n\nimport { keccak_256 } from '@noble/hashes/sha3';\n\n/**\n * Converts a hex string to Uint8Array\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  const cleanHex = hex.replace(/^0x/, '');\n  const bytes = new Uint8Array(cleanHex.length / 2);\n  for (let i = 0; i < bytes.length; i++) {\n    bytes[i] = parseInt(cleanHex.substr(i * 2, 2), 16);\n  }\n  return bytes;\n}\n\n/**\n * Converts Uint8Array to hex string\n */\nexport function bytesToHex(bytes: Uint8Array, prefix = true): string {\n  const hex = Array.from(bytes)\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('');\n  return prefix ? `0x${hex}` : hex;\n}\n\n/**\n * Computes keccak256 hash\n */\nexport function keccak256(data: Uint8Array | string): string {\n  const input = typeof data === 'string' ? hexToBytes(data) : data;\n  const hash = keccak_256(input);\n  return bytesToHex(hash);\n}\n\n/**\n * Pads a hex string to a specific length\n */\nexport function padHex(hex: string, length: number, side: 'left' | 'right' = 'left'): string {\n  const cleanHex = hex.replace(/^0x/, '');\n  const padded = side === 'left'\n    ? cleanHex.padStart(length, '0')\n    : cleanHex.padEnd(length, '0');\n  return `0x${padded}`;\n}\n\n/**\n * Formats a bigint as a decimal string with specified decimals\n */\nexport function formatUnits(value: bigint, decimals: number): string {\n  const negative = value < 0n;\n  const absValue = negative ? -value : value;\n\n  const str = absValue.toString().padStart(decimals + 1, '0');\n  const integerPart = str.slice(0, -decimals) || '0';\n  const decimalPart = str.slice(-decimals);\n\n  // Trim trailing zeros from decimal part\n  const trimmedDecimal = decimalPart.replace(/0+$/, '');\n\n  const result = trimmedDecimal ? `${integerPart}.${trimmedDecimal}` : integerPart;\n  return negative ? `-${result}` : result;\n}\n\n/**\n * Parses a decimal string to bigint with specified decimals\n */\nexport function parseUnits(value: string, decimals: number): bigint {\n  const negative = value.startsWith('-');\n  const cleanValue = negative ? value.slice(1) : value;\n\n  const [integerPart, decimalPart = ''] = cleanValue.split('.');\n\n  // Pad or truncate decimal part to match decimals\n  const paddedDecimal = decimalPart.padEnd(decimals, '0').slice(0, decimals);\n\n  const combined = integerPart + paddedDecimal;\n  const result = BigInt(combined);\n\n  return negative ? -result : result;\n}\n\n/**\n * Formats XLM (7 decimals) for display\n */\nexport function formatXlm(stroops: bigint): string {\n  return formatUnits(stroops, 7);\n}\n\n/**\n * Parses XLM string to stroops\n */\nexport function parseXlm(xlm: string): bigint {\n  return parseUnits(xlm, 7);\n}\n\n/**\n * Formats ETH-style value (18 decimals) for display\n */\nexport function formatEth(wei: bigint): string {\n  return formatUnits(wei, 18);\n}\n\n/**\n * Parses ETH string to wei\n */\nexport function parseEth(eth: string): bigint {\n  return parseUnits(eth, 18);\n}\n\n/**\n * Validates an EVM address format\n */\nexport function isValidEvmAddress(address: string): boolean {\n  return /^0x[0-9a-fA-F]{40}$/.test(address);\n}\n\n/**\n * Validates a Stellar G-address format\n */\nexport function isValidStellarAddress(address: string): boolean {\n  return /^G[A-Z2-7]{55}$/.test(address);\n}\n\n/**\n * Validates a Soroban C-address format\n */\nexport function isValidContractId(address: string): boolean {\n  return /^C[A-Z2-7]{55}$/.test(address);\n}\n\n/**\n * Checksums an EVM address (EIP-55)\n */\nexport function checksumAddress(address: string): string {\n  const addr = address.toLowerCase().replace(/^0x/, '');\n  const hash = keccak256(new TextEncoder().encode(addr)).replace(/^0x/, '');\n\n  let checksummed = '0x';\n  for (let i = 0; i < addr.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      checksummed += addr[i].toUpperCase();\n    } else {\n      checksummed += addr[i];\n    }\n  }\n\n  return checksummed;\n}\n\n/**\n * Validates a checksummed EVM address (EIP-55)\n */\nexport function isValidChecksumAddress(address: string): boolean {\n  if (!isValidEvmAddress(address)) return false;\n  return address === checksumAddress(address);\n}\n\n/**\n * Sleep for a specified number of milliseconds\n */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Retry a function with exponential backoff\n */\nexport async function retry<T>(\n  fn: () => Promise<T>,\n  options: {\n    maxRetries?: number;\n    initialDelay?: number;\n    maxDelay?: number;\n    shouldRetry?: (error: unknown) => boolean;\n  } = {}\n): Promise<T> {\n  const {\n    maxRetries = 3,\n    initialDelay = 1000,\n    maxDelay = 30000,\n    shouldRetry = () => true,\n  } = options;\n\n  let lastError: unknown;\n  let delay = initialDelay;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error;\n\n      if (attempt === maxRetries || !shouldRetry(error)) {\n        throw error;\n      }\n\n      await sleep(delay);\n      delay = Math.min(delay * 2, maxDelay);\n    }\n  }\n\n  throw lastError;\n}\n\n/**\n * Creates a deferred promise\n */\nexport function deferred<T>(): {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (error: unknown) => void;\n} {\n  let resolve!: (value: T) => void;\n  let reject!: (error: unknown) => void;\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise, resolve, reject };\n}\n\n/**\n * Chunks an array into smaller arrays\n */\nexport function chunk<T>(array: T[], size: number): T[][] {\n  const chunks: T[][] = [];\n  for (let i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n"]}