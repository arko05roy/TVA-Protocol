{"version":3,"sources":["../../src/types/index.ts","../../src/compiler/solang.ts"],"names":["fs"],"mappings":"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","file":"index.mjs","sourcesContent":["/**\n * TVA Protocol Type Definitions\n *\n * These types define the core abstractions for the TVA Protocol,\n * bridging EVM and Stellar/Soroban concepts.\n */\n\n// ============================================================================\n// Network Configuration\n// ============================================================================\n\nexport type NetworkType = 'testnet' | 'mainnet' | 'local';\n\nexport interface NetworkConfig {\n  /** Network identifier */\n  type: NetworkType;\n  /** TVA RPC endpoint URL */\n  rpcUrl: string;\n  /** Stellar Horizon URL */\n  horizonUrl: string;\n  /** Stellar Soroban RPC URL */\n  sorobanRpcUrl: string;\n  /** Network passphrase for Stellar */\n  networkPassphrase: string;\n  /** Chain ID for EVM compatibility */\n  chainId: number;\n  /** Native currency symbol (XLM) */\n  nativeCurrency: {\n    name: string;\n    symbol: string;\n    decimals: number;\n  };\n}\n\nexport const NETWORKS: Record<NetworkType, NetworkConfig> = {\n  testnet: {\n    type: 'testnet',\n    rpcUrl: 'https://rpc.testnet.tva-protocol.io',\n    horizonUrl: 'https://horizon-testnet.stellar.org',\n    sorobanRpcUrl: 'https://soroban-testnet.stellar.org',\n    networkPassphrase: 'Test SDF Network ; September 2015',\n    chainId: 0x544541, // \"TVA\" in hex (test)\n    nativeCurrency: {\n      name: 'Stellar Lumens',\n      symbol: 'XLM',\n      decimals: 7,\n    },\n  },\n  mainnet: {\n    type: 'mainnet',\n    rpcUrl: 'https://rpc.tva-protocol.io',\n    horizonUrl: 'https://horizon.stellar.org',\n    sorobanRpcUrl: 'https://soroban.stellar.org',\n    networkPassphrase: 'Public Global Stellar Network ; September 2015',\n    chainId: 0x545641, // \"TVA\" in hex\n    nativeCurrency: {\n      name: 'Stellar Lumens',\n      symbol: 'XLM',\n      decimals: 7,\n    },\n  },\n  local: {\n    type: 'local',\n    rpcUrl: 'http://localhost:8545',\n    horizonUrl: 'http://localhost:8000',\n    sorobanRpcUrl: 'http://localhost:8001',\n    networkPassphrase: 'Standalone Network ; February 2017',\n    chainId: 0x545600, // \"TV\" + 0x00\n    nativeCurrency: {\n      name: 'Stellar Lumens',\n      symbol: 'XLM',\n      decimals: 7,\n    },\n  },\n};\n\n// ============================================================================\n// Address Types\n// ============================================================================\n\n/** 20-byte EVM-compatible address (hex string with 0x prefix) */\nexport type EvmAddress = `0x${string}`;\n\n/** 56-character Stellar G-address (Ed25519 public key) */\nexport type StellarAddress = `G${string}`;\n\n/** Soroban contract ID (C-address, 56 characters) */\nexport type SorobanContractId = `C${string}`;\n\n/** Generic address that could be EVM or Stellar format */\nexport type Address = EvmAddress | StellarAddress | SorobanContractId;\n\n/** Mapping between EVM and Stellar addresses */\nexport interface AddressMapping {\n  evmAddress: EvmAddress;\n  stellarAddress: StellarAddress;\n  registeredAt: number; // ledger sequence\n}\n\n// ============================================================================\n// Transaction Types\n// ============================================================================\n\nexport interface EvmTransaction {\n  from: EvmAddress;\n  to?: EvmAddress; // undefined for contract deployment\n  value: bigint;\n  data: string;\n  nonce: number;\n  gasLimit: bigint;\n  gasPrice: bigint;\n  chainId: number;\n}\n\nexport interface EvmTransactionReceipt {\n  transactionHash: string;\n  transactionIndex: number;\n  blockHash: string;\n  blockNumber: number;\n  from: EvmAddress;\n  to: EvmAddress | null;\n  contractAddress: EvmAddress | null;\n  cumulativeGasUsed: bigint;\n  gasUsed: bigint;\n  status: 0 | 1;\n  logs: EvmLog[];\n}\n\nexport interface EvmLog {\n  address: EvmAddress;\n  topics: string[];\n  data: string;\n  blockNumber: number;\n  transactionHash: string;\n  transactionIndex: number;\n  blockHash: string;\n  logIndex: number;\n  removed: boolean;\n}\n\nexport interface EvmBlock {\n  number: number;\n  hash: string;\n  parentHash: string;\n  timestamp: number;\n  miner: EvmAddress;\n  difficulty: bigint;\n  totalDifficulty: bigint;\n  gasLimit: bigint;\n  gasUsed: bigint;\n  transactions: string[];\n  transactionsRoot: string;\n  stateRoot: string;\n  receiptsRoot: string;\n  logsBloom: string;\n  nonce: string;\n  extraData: string;\n}\n\n// ============================================================================\n// Compilation Types\n// ============================================================================\n\nexport interface CompilerInput {\n  /** Solidity source code */\n  source: string;\n  /** Contract file name */\n  fileName: string;\n  /** Compiler optimization settings */\n  optimization?: {\n    enabled: boolean;\n    runs?: number;\n  };\n}\n\nexport interface CompilerOutput {\n  /** Compiled WASM binary (base64 encoded) */\n  wasm: string;\n  /** Contract ABI in JSON format */\n  abi: ContractABI;\n  /** Soroban contract spec entries */\n  spec: SorobanSpec[];\n  /** Compilation warnings */\n  warnings: string[];\n  /** Source map for debugging */\n  sourceMap?: string;\n}\n\nexport interface ContractABI {\n  /** Contract name */\n  name: string;\n  /** ABI entries */\n  functions: ABIFunction[];\n  events: ABIEvent[];\n  errors: ABIError[];\n}\n\nexport interface ABIFunction {\n  name: string;\n  inputs: ABIParameter[];\n  outputs: ABIParameter[];\n  stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';\n  type: 'function' | 'constructor' | 'fallback' | 'receive';\n}\n\nexport interface ABIEvent {\n  name: string;\n  inputs: ABIEventParameter[];\n  anonymous: boolean;\n}\n\nexport interface ABIParameter {\n  name: string;\n  type: string;\n  internalType?: string;\n  components?: ABIParameter[];\n}\n\nexport interface ABIEventParameter extends ABIParameter {\n  indexed: boolean;\n}\n\nexport interface ABIError {\n  name: string;\n  inputs: ABIParameter[];\n}\n\nexport interface SorobanSpec {\n  type: 'function' | 'struct' | 'union' | 'enum' | 'error';\n  name: string;\n  doc?: string;\n  inputs?: { name: string; type: ScValType }[];\n  outputs?: ScValType[];\n}\n\n// ============================================================================\n// Soroban-Specific Types\n// ============================================================================\n\nexport type ScValType =\n  | 'bool'\n  | 'void'\n  | 'error'\n  | 'u32'\n  | 'i32'\n  | 'u64'\n  | 'i64'\n  | 'timepoint'\n  | 'duration'\n  | 'u128'\n  | 'i128'\n  | 'u256'\n  | 'i256'\n  | 'bytes'\n  | 'string'\n  | 'symbol'\n  | 'address'\n  | { vec: ScValType }\n  | { map: { key: ScValType; value: ScValType } }\n  | { option: ScValType }\n  | { result: { ok: ScValType; err: ScValType } }\n  | { tuple: ScValType[] }\n  | { bytesN: number }\n  | { struct: string }\n  | { union: string }\n  | { enum: string };\n\nexport type StorageType = 'temporary' | 'instance' | 'persistent';\n\nexport interface StorageEntry {\n  key: string;\n  value: unknown;\n  type: StorageType;\n  ttl: number; // ledger sequence when entry expires\n}\n\n// ============================================================================\n// Contract Interaction Types\n// ============================================================================\n\nexport interface DeploymentConfig {\n  /** Compiled WASM binary (base64) */\n  wasm: string;\n  /** Constructor arguments */\n  constructorArgs?: unknown[];\n  /** Initial salt for address derivation */\n  salt?: string;\n  /** Network to deploy to */\n  network: NetworkType;\n}\n\nexport interface DeploymentResult {\n  /** Soroban contract ID */\n  contractId: SorobanContractId;\n  /** EVM-compatible contract address */\n  evmAddress: EvmAddress;\n  /** Deployment transaction hash (Stellar format) */\n  stellarTxHash: string;\n  /** Deployment transaction hash (EVM format) */\n  evmTxHash: string;\n  /** Ledger sequence of deployment */\n  ledgerSequence: number;\n}\n\nexport interface ContractCallConfig {\n  /** Contract address (EVM or Soroban format) */\n  contractAddress: Address;\n  /** Function name to call */\n  functionName: string;\n  /** Function arguments */\n  args?: unknown[];\n  /** Caller address */\n  from?: Address;\n}\n\nexport interface ContractCallResult<T = unknown> {\n  /** Return value from the contract */\n  result: T;\n  /** Gas/resource consumption */\n  gasUsed: bigint;\n  /** Events emitted during call */\n  events: EvmLog[];\n  /** Whether the call was a simulation (view) or on-chain */\n  simulated: boolean;\n}\n\n// ============================================================================\n// Wallet Types\n// ============================================================================\n\nexport interface KeyPair {\n  /** secp256k1 private key for EVM signing */\n  evmPrivateKey: string;\n  /** secp256k1 public key (uncompressed, 65 bytes) */\n  evmPublicKey: string;\n  /** Ed25519 secret key for Stellar signing */\n  stellarSecretKey: string;\n  /** Ed25519 public key for Stellar */\n  stellarPublicKey: string;\n}\n\nexport interface Account {\n  /** EVM-format address */\n  evmAddress: EvmAddress;\n  /** Stellar G-address */\n  stellarAddress: StellarAddress;\n  /** Whether this account is registered in the AccountRegistry */\n  isRegistered: boolean;\n  /** Account sequence number (Stellar) */\n  sequenceNumber?: string;\n  /** Account nonce (EVM) */\n  nonce?: number;\n}\n\nexport interface Balance {\n  /** Native XLM balance (in stroops, 1 XLM = 10^7 stroops) */\n  xlm: bigint;\n  /** Native XLM balance formatted (7 decimals) */\n  xlmFormatted: string;\n  /** Token balances keyed by contract address */\n  tokens: Map<Address, TokenBalance>;\n}\n\nexport interface TokenBalance {\n  /** Token contract address */\n  address: Address;\n  /** Token symbol */\n  symbol: string;\n  /** Token decimals */\n  decimals: number;\n  /** Raw balance */\n  balance: bigint;\n  /** Formatted balance */\n  balanceFormatted: string;\n}\n\n// ============================================================================\n// Error Types\n// ============================================================================\n\nexport class TVAError extends Error {\n  constructor(\n    message: string,\n    public code: TVAErrorCode,\n    public details?: Record<string, unknown>\n  ) {\n    super(message);\n    this.name = 'TVAError';\n  }\n}\n\nexport enum TVAErrorCode {\n  // Compilation errors (1xxx)\n  COMPILATION_FAILED = 1001,\n  SOLANG_NOT_FOUND = 1002,\n  INVALID_SOURCE = 1003,\n\n  // Network errors (2xxx)\n  NETWORK_ERROR = 2001,\n  RPC_ERROR = 2002,\n  TIMEOUT = 2003,\n\n  // Transaction errors (3xxx)\n  TRANSACTION_FAILED = 3001,\n  INSUFFICIENT_BALANCE = 3002,\n  INVALID_NONCE = 3003,\n  GAS_ESTIMATION_FAILED = 3004,\n\n  // Contract errors (4xxx)\n  CONTRACT_NOT_FOUND = 4001,\n  CONTRACT_REVERT = 4002,\n  INVALID_ARGUMENTS = 4003,\n\n  // Account errors (5xxx)\n  ACCOUNT_NOT_FOUND = 5001,\n  ACCOUNT_NOT_REGISTERED = 5002,\n  INVALID_SIGNATURE = 5003,\n\n  // Storage errors (6xxx)\n  STATE_ARCHIVED = 6001,\n  TTL_EXPIRED = 6002,\n  RESTORATION_FAILED = 6003,\n}\n","/**\n * TVA Protocol Solang Compiler Wrapper\n *\n * Wraps the Solang compiler binary for compiling Solidity to Soroban WASM.\n * Handles binary discovery, invocation, output parsing, and error translation.\n */\n\nimport { spawn } from 'child_process';\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\nimport * as os from 'os';\nimport type {\n  CompilerInput,\n  CompilerOutput,\n  ContractABI,\n  ABIFunction,\n  ABIEvent,\n  ABIError,\n  SorobanSpec,\n} from '../types/index.js';\nimport { TVAError, TVAErrorCode } from '../types/index.js';\n\n/**\n * Paths where Solang binary might be located\n */\nconst SOLANG_BINARY_PATHS = [\n  // User-specified path via environment variable\n  process.env.TVA_SOLANG_PATH,\n  // Local project path\n  path.join(process.cwd(), 'solang'),\n  path.join(process.cwd(), 'bin', 'solang'),\n  // TVA tooling path\n  path.join(process.cwd(), 'tooling', 'solang', 'target', 'release', 'solang'),\n  // Global installations\n  '/usr/local/bin/solang',\n  '/usr/bin/solang',\n  // Homebrew (macOS)\n  '/opt/homebrew/bin/solang',\n  // Cargo installation\n  path.join(os.homedir(), '.cargo', 'bin', 'solang'),\n].filter(Boolean) as string[];\n\n/**\n * Finds the Solang binary\n */\nasync function findSolangBinary(): Promise<string> {\n  for (const binaryPath of SOLANG_BINARY_PATHS) {\n    try {\n      await fs.access(binaryPath, fs.constants.X_OK);\n      return binaryPath;\n    } catch {\n      // Binary not found at this path, try next\n    }\n  }\n\n  throw new TVAError(\n    'Solang compiler not found. Please install Solang or set TVA_SOLANG_PATH environment variable.',\n    TVAErrorCode.SOLANG_NOT_FOUND,\n    {\n      searchedPaths: SOLANG_BINARY_PATHS,\n    }\n  );\n}\n\n/**\n * Compiler options\n */\nexport interface SolangCompilerOptions {\n  /** Path to Solang binary (auto-detected if not specified) */\n  solangPath?: string;\n  /** Optimization level (0-3) */\n  optimizationLevel?: number;\n  /** Output directory for compiled artifacts */\n  outputDir?: string;\n  /** Additional Solang flags */\n  additionalFlags?: string[];\n  /** Import paths for Solidity imports */\n  importPaths?: string[];\n}\n\n/**\n * Compiled contract artifact\n */\nexport interface CompiledContract {\n  /** Contract name */\n  name: string;\n  /** WASM binary (as Buffer) */\n  wasm: Buffer;\n  /** Contract ABI */\n  abi: ContractABI;\n  /** Soroban spec entries */\n  spec: SorobanSpec[];\n  /** Source file path */\n  sourcePath: string;\n  /** Compilation warnings */\n  warnings: string[];\n}\n\n/**\n * Solang compiler wrapper\n */\nexport class SolangCompiler {\n  private solangPath: string | null = null;\n  private options: SolangCompilerOptions;\n\n  constructor(options: SolangCompilerOptions = {}) {\n    this.options = {\n      optimizationLevel: 2,\n      ...options,\n    };\n  }\n\n  /**\n   * Initializes the compiler by finding the Solang binary\n   */\n  async initialize(): Promise<void> {\n    if (this.options.solangPath) {\n      this.solangPath = this.options.solangPath;\n    } else {\n      this.solangPath = await findSolangBinary();\n    }\n  }\n\n  /**\n   * Gets the Solang version\n   */\n  async getVersion(): Promise<string> {\n    if (!this.solangPath) {\n      await this.initialize();\n    }\n\n    return new Promise((resolve, reject) => {\n      const proc = spawn(this.solangPath!, ['--version']);\n      let output = '';\n\n      proc.stdout.on('data', (data) => {\n        output += data.toString();\n      });\n\n      proc.on('close', (code) => {\n        if (code === 0) {\n          // Parse version from output like \"solang version v0.3.3\"\n          const match = output.match(/solang version v?([\\d.]+)/i);\n          resolve(match ? match[1] : output.trim());\n        } else {\n          reject(new Error('Failed to get Solang version'));\n        }\n      });\n    });\n  }\n\n  /**\n   * Compiles a Solidity source file to Soroban WASM\n   */\n  async compile(input: CompilerInput): Promise<CompilerOutput> {\n    if (!this.solangPath) {\n      await this.initialize();\n    }\n\n    // Create temporary directory for compilation\n    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'tva-compile-'));\n    const sourceFile = path.join(tempDir, input.fileName);\n    const outputDir = this.options.outputDir || tempDir;\n\n    try {\n      // Write source file\n      await fs.writeFile(sourceFile, input.source);\n\n      // Build Solang command\n      const args = [\n        'compile',\n        sourceFile,\n        '--target', 'soroban',\n        '-o', outputDir,\n      ];\n\n      // Add optimization level\n      if (this.options.optimizationLevel !== undefined) {\n        args.push(`-O${this.options.optimizationLevel}`);\n      }\n\n      // Add import paths\n      if (this.options.importPaths) {\n        for (const importPath of this.options.importPaths) {\n          args.push('-I', importPath);\n        }\n      }\n\n      // Add additional flags\n      if (this.options.additionalFlags) {\n        args.push(...this.options.additionalFlags);\n      }\n\n      // Run Solang\n      const result = await this.runSolang(args);\n\n      if (result.exitCode !== 0 && !result.stdout.includes('.wasm')) {\n        throw new TVAError(\n          `Compilation failed: ${result.stderr || result.stdout}`,\n          TVAErrorCode.COMPILATION_FAILED,\n          {\n            stdout: result.stdout,\n            stderr: result.stderr,\n            exitCode: result.exitCode,\n          }\n        );\n      }\n\n      // Find output files\n      const files = await fs.readdir(outputDir);\n      const wasmFile = files.find((f) => f.endsWith('.wasm'));\n      const abiFile = files.find((f) => f.endsWith('.abi') || f.endsWith('.json'));\n\n      if (!wasmFile) {\n        throw new TVAError(\n          'No WASM file produced by compilation',\n          TVAErrorCode.COMPILATION_FAILED,\n          {\n            outputFiles: files,\n            stdout: result.stdout,\n            stderr: result.stderr,\n          }\n        );\n      }\n\n      // Read WASM file\n      const wasmPath = path.join(outputDir, wasmFile);\n      const wasmBuffer = await fs.readFile(wasmPath);\n\n      // Parse ABI if available\n      let abi: ContractABI = {\n        name: input.fileName.replace('.sol', ''),\n        functions: [],\n        events: [],\n        errors: [],\n      };\n\n      if (abiFile) {\n        const abiPath = path.join(outputDir, abiFile);\n        const abiContent = await fs.readFile(abiPath, 'utf-8');\n        abi = this.parseABI(abiContent, input.fileName);\n      }\n\n      // Extract spec from WASM (custom section)\n      const spec = this.extractSorobanSpec(wasmBuffer);\n\n      // Parse warnings from output\n      const warnings = this.parseWarnings(result.stdout + result.stderr);\n\n      return {\n        wasm: wasmBuffer.toString('base64'),\n        abi,\n        spec,\n        warnings,\n      };\n    } finally {\n      // Clean up temp directory if we created one\n      if (!this.options.outputDir) {\n        await fs.rm(tempDir, { recursive: true, force: true }).catch(() => {});\n      }\n    }\n  }\n\n  /**\n   * Compiles a Solidity source file and returns detailed artifacts\n   */\n  async compileFile(filePath: string): Promise<CompiledContract[]> {\n    const source = await fs.readFile(filePath, 'utf-8');\n    const fileName = path.basename(filePath);\n\n    const output = await this.compile({\n      source,\n      fileName,\n    });\n\n    // For now, return a single contract\n    // In the future, handle multiple contracts per file\n    return [\n      {\n        name: output.abi.name,\n        wasm: Buffer.from(output.wasm, 'base64'),\n        abi: output.abi,\n        spec: output.spec,\n        sourcePath: filePath,\n        warnings: output.warnings,\n      },\n    ];\n  }\n\n  /**\n   * Compiles multiple Solidity files\n   */\n  async compileFiles(filePaths: string[]): Promise<CompiledContract[]> {\n    const results: CompiledContract[] = [];\n\n    for (const filePath of filePaths) {\n      const contracts = await this.compileFile(filePath);\n      results.push(...contracts);\n    }\n\n    return results;\n  }\n\n  /**\n   * Runs Solang with the given arguments\n   */\n  private runSolang(args: string[]): Promise<{\n    exitCode: number;\n    stdout: string;\n    stderr: string;\n  }> {\n    return new Promise((resolve) => {\n      const proc = spawn(this.solangPath!, args);\n      let stdout = '';\n      let stderr = '';\n\n      proc.stdout.on('data', (data) => {\n        stdout += data.toString();\n      });\n\n      proc.stderr.on('data', (data) => {\n        stderr += data.toString();\n      });\n\n      proc.on('close', (exitCode) => {\n        resolve({\n          exitCode: exitCode ?? 1,\n          stdout,\n          stderr,\n        });\n      });\n\n      proc.on('error', (error) => {\n        resolve({\n          exitCode: 1,\n          stdout,\n          stderr: stderr + error.message,\n        });\n      });\n    });\n  }\n\n  /**\n   * Parses Solang ABI output\n   */\n  private parseABI(abiContent: string, fileName: string): ContractABI {\n    try {\n      const parsed = JSON.parse(abiContent);\n\n      // Handle both array format (standard) and object format (Solang)\n      const entries = Array.isArray(parsed) ? parsed : parsed.abi || [];\n\n      const functions: ABIFunction[] = [];\n      const events: ABIEvent[] = [];\n      const errors: ABIError[] = [];\n\n      for (const entry of entries) {\n        if (entry.type === 'function' || !entry.type) {\n          functions.push({\n            name: entry.name,\n            inputs: entry.inputs || [],\n            outputs: entry.outputs || [],\n            stateMutability: entry.stateMutability || 'nonpayable',\n            type: 'function',\n          });\n        } else if (entry.type === 'constructor') {\n          functions.push({\n            name: 'constructor',\n            inputs: entry.inputs || [],\n            outputs: [],\n            stateMutability: entry.stateMutability || 'nonpayable',\n            type: 'constructor',\n          });\n        } else if (entry.type === 'event') {\n          events.push({\n            name: entry.name,\n            inputs: entry.inputs || [],\n            anonymous: entry.anonymous || false,\n          });\n        } else if (entry.type === 'error') {\n          errors.push({\n            name: entry.name,\n            inputs: entry.inputs || [],\n          });\n        }\n      }\n\n      return {\n        name: parsed.name || fileName.replace('.sol', ''),\n        functions,\n        events,\n        errors,\n      };\n    } catch (error) {\n      // Return empty ABI on parse error\n      return {\n        name: fileName.replace('.sol', ''),\n        functions: [],\n        events: [],\n        errors: [],\n      };\n    }\n  }\n\n  /**\n   * Extracts Soroban spec from WASM custom section\n   */\n  private extractSorobanSpec(wasmBuffer: Buffer): SorobanSpec[] {\n    // Soroban stores contract spec in a custom section named \"contractspecv0\"\n    // For now, return empty array - full implementation requires WASM parsing\n    // This will be enhanced when we integrate with the Stellar SDK's spec extraction\n    try {\n      const specs: SorobanSpec[] = [];\n\n      // Simple WASM custom section parser\n      let offset = 8; // Skip magic number and version\n\n      while (offset < wasmBuffer.length) {\n        const sectionId = wasmBuffer[offset++];\n        const sectionSize = this.readLEB128(wasmBuffer, offset);\n        offset = sectionSize.offset;\n\n        if (sectionId === 0) {\n          // Custom section\n          const nameLen = this.readLEB128(wasmBuffer, offset);\n          offset = nameLen.offset;\n\n          const name = wasmBuffer.slice(offset, offset + nameLen.value).toString('utf-8');\n          offset += nameLen.value;\n\n          if (name === 'contractspecv0') {\n            // Found the spec section - parse it\n            // The spec is XDR encoded, so we'd need the Stellar SDK to decode it\n            // For now, just note that we found it\n            specs.push({\n              type: 'function',\n              name: '_spec_found',\n              doc: 'Soroban spec section found in WASM',\n            });\n          }\n        }\n\n        offset += sectionSize.value - (offset - sectionSize.offset);\n      }\n\n      return specs;\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Reads a LEB128 encoded integer from a buffer\n   */\n  private readLEB128(\n    buffer: Buffer,\n    offset: number\n  ): { value: number; offset: number } {\n    let result = 0;\n    let shift = 0;\n    let byte: number;\n\n    do {\n      byte = buffer[offset++];\n      result |= (byte & 0x7f) << shift;\n      shift += 7;\n    } while (byte & 0x80);\n\n    return { value: result, offset };\n  }\n\n  /**\n   * Parses compilation warnings from Solang output\n   */\n  private parseWarnings(output: string): string[] {\n    const warnings: string[] = [];\n    const lines = output.split('\\n');\n\n    for (const line of lines) {\n      if (line.includes('warning:') || line.includes('Warning:')) {\n        warnings.push(line.trim());\n      }\n    }\n\n    return warnings;\n  }\n}\n\n/**\n * Convenience function to compile a single file\n */\nexport async function compileSource(\n  source: string,\n  fileName: string = 'Contract.sol',\n  options?: SolangCompilerOptions\n): Promise<CompilerOutput> {\n  const compiler = new SolangCompiler(options);\n  return compiler.compile({ source, fileName });\n}\n\n/**\n * Convenience function to compile a file from disk\n */\nexport async function compileFile(\n  filePath: string,\n  options?: SolangCompilerOptions\n): Promise<CompiledContract[]> {\n  const compiler = new SolangCompiler(options);\n  return compiler.compileFile(filePath);\n}\n"]}