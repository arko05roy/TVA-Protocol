{"version":3,"sources":["../../src/wallet/keys.ts","../../src/types/index.ts","../../src/wallet/signer.ts"],"names":["ed25519","sha512","hmac","secp256k1","keccak_256","StrKey","generateMnemonic","bip39","validateMnemonic","sha256","Keypair","secp256k12","lengthBytes","xdr"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBQA,kBAAA,CAAA,GAAA,CAAI,UAAA,GAAa,IAAI,CAAA,KAAMC,aAAA,CAAeD,uBAAI,WAAA,CAAY,GAAG,CAAC,CAAC,CAAA;AAKvE,SAAS,0BAAA,CACP,MACA,IAAA,EACY;AAEZ,EAAA,MAAM,CAAA,GAAIE,UAAKD,aAAA,EAAQ,IAAI,aAAY,CAAE,MAAA,CAAO,cAAc,CAAA,EAAG,IAAI,CAAA;AACrE,EAAA,IAAI,MAAM,IAAI,UAAA,CAAW,EAAE,KAAA,CAAM,CAAA,EAAG,EAAE,CAAC,CAAA;AACvC,EAAA,IAAI,YAAY,IAAI,UAAA,CAAW,CAAA,CAAE,KAAA,CAAM,EAAE,CAAC,CAAA;AAG1C,EAAA,MAAM,QAAA,GAAW,IAAA,CACd,OAAA,CAAQ,MAAA,EAAQ,EAAE,CAAA,CAClB,KAAA,CAAM,GAAG,CAAA,CACT,GAAA,CAAI,CAAC,CAAA,KAAM;AACV,IAAA,MAAM,QAAA,GAAW,CAAA,CAAE,QAAA,CAAS,GAAG,CAAA;AAC/B,IAAA,MAAM,QAAQ,QAAA,CAAS,CAAA,CAAE,QAAQ,GAAA,EAAK,EAAE,GAAG,EAAE,CAAA;AAC7C,IAAA,OAAO,EAAE,OAAO,QAAA,EAAS;AAAA,EAC3B,CAAC,CAAA;AAEH,EAAA,KAAA,MAAW,WAAW,QAAA,EAAU;AAC9B,IAAA,MAAM,WAAA,GAAc,IAAI,UAAA,CAAW,CAAC,CAAA;AACpC,IAAA,MAAM,IAAA,GAAO,IAAI,QAAA,CAAS,WAAA,CAAY,MAAM,CAAA;AAE5C,IAAA,IAAI,IAAA;AACJ,IAAA,IAAI,QAAQ,QAAA,EAAU;AACpB,MAAA,MAAM,aAAA,GAAgB,QAAQ,KAAA,GAAQ,UAAA;AACtC,MAAA,IAAA,CAAK,SAAA,CAAU,CAAA,EAAG,aAAA,EAAe,KAAK,CAAA;AACtC,MAAA,IAAA,GAAO,IAAI,UAAA,CAAW,CAAA,GAAI,EAAA,GAAK,CAAC,CAAA;AAChC,MAAA,IAAA,CAAK,CAAC,CAAA,GAAI,CAAA;AACV,MAAA,IAAA,CAAK,GAAA,CAAI,KAAK,CAAC,CAAA;AACf,MAAA,IAAA,CAAK,GAAA,CAAI,aAAa,EAAE,CAAA;AAAA,IAC1B,CAAA,MAAO;AACL,MAAA,IAAA,CAAK,SAAA,CAAU,CAAA,EAAG,OAAA,CAAQ,KAAA,EAAO,KAAK,CAAA;AACtC,MAAA,MAAM,SAAA,GAAsBE,oBAAA,CAAA,YAAA,CAAa,GAAA,EAAK,IAAI,CAAA;AAClD,MAAA,IAAA,GAAO,IAAI,UAAA,CAAW,EAAA,GAAK,CAAC,CAAA;AAC5B,MAAA,IAAA,CAAK,GAAA,CAAI,WAAW,CAAC,CAAA;AACrB,MAAA,IAAA,CAAK,GAAA,CAAI,aAAa,EAAE,CAAA;AAAA,IAC1B;AAEA,IAAA,MAAM,EAAA,GAAKD,SAAA,CAAKD,aAAA,EAAQ,SAAA,EAAW,IAAI,CAAA;AACvC,IAAA,MAAM,KAAK,IAAI,UAAA,CAAW,GAAG,KAAA,CAAM,CAAA,EAAG,EAAE,CAAC,CAAA;AACzC,IAAA,SAAA,GAAY,IAAI,UAAA,CAAW,EAAA,CAAG,KAAA,CAAM,EAAE,CAAC,CAAA;AAGvC,IAAA,MAAM,eAAA,GAAkB,cAAc,GAAG,CAAA;AACzC,IAAA,MAAM,QAAA,GAAW,cAAc,EAAE,CAAA;AACjC,IAAA,MAAM,CAAA,GAAI,MAAA;AAAA,MACR;AAAA,KACF;AACA,IAAA,MAAM,cAAA,GAAA,CAAkB,WAAW,eAAA,IAAmB,CAAA;AACtD,IAAA,GAAA,GAAM,aAAA,CAAc,gBAAgB,EAAE,CAAA;AAAA,EACxC;AAEA,EAAA,OAAO,GAAA;AACT;AAEA,SAAS,cAAc,KAAA,EAA2B;AAChD,EAAA,IAAI,MAAA,GAAS,OAAO,CAAC,CAAA;AACrB,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AACrC,IAAA,MAAA,GAAU,UAAU,MAAA,CAAO,CAAC,IAAK,MAAA,CAAO,KAAA,CAAM,CAAC,CAAC,CAAA;AAAA,EAClD;AACA,EAAA,OAAO,MAAA;AACT;AAEA,SAAS,aAAA,CAAc,OAAe,MAAA,EAAyC;AAC7E,EAAA,MAAM,MAAA,GAAS,IAAI,UAAA,CAAW,MAAM,CAAA;AACpC,EAAA,IAAI,CAAA,GAAI,KAAA;AACR,EAAA,KAAA,IAAS,CAAA,GAAI,MAAA,GAAS,CAAA,EAAG,CAAA,IAAK,GAAG,CAAA,EAAA,EAAK;AACpC,IAAA,MAAA,CAAO,CAAC,CAAA,GAAI,MAAA,CAAO,CAAA,GAAI,MAAA,CAAO,GAAI,CAAC,CAAA;AACnC,IAAA,CAAA,GAAI,CAAA,IAAK,OAAO,CAAC,CAAA;AAAA,EACnB;AACA,EAAA,OAAO,MAAA;AACT;AAKO,SAAS,sBAAsB,SAAA,EAAmC;AAEvE,EAAA,MAAM,mBACJ,SAAA,CAAU,MAAA,KAAW,KAAK,SAAA,CAAU,KAAA,CAAM,CAAC,CAAA,GAAI,SAAA;AAGjD,EAAA,MAAM,IAAA,GAAOG,gBAAW,gBAAgB,CAAA;AAGxC,EAAA,MAAM,eAAe,IAAI,UAAA,CAAW,IAAA,CAAK,KAAA,CAAM,GAAG,CAAC,CAAA;AAGnD,EAAA,MAAM,MAAM,KAAA,CAAM,IAAA,CAAK,YAAY,CAAA,CAChC,GAAA,CAAI,CAAC,CAAA,KAAM,CAAA,CAAE,QAAA,CAAS,EAAE,EAAE,QAAA,CAAS,CAAA,EAAG,GAAG,CAAC,CAAA,CAC1C,KAAK,EAAE,CAAA;AAEV,EAAA,OAAO,KAAK,GAAG,CAAA,CAAA;AACjB;AAKO,SAAS,0BACd,SAAA,EACgB;AAChB,EAAA,OAAOC,iBAAA,CAAO,sBAAA,CAAuB,MAAA,CAAO,IAAA,CAAK,SAAS,CAAC,CAAA;AAC7D;AAYO,SAASC,iBAAAA,CAAiB,WAAsB,GAAA,EAAa;AAClE,EAAA,OAAaC,kCAAiB,QAAQ,CAAA;AACxC;AAKO,SAASC,kBAAiB,QAAA,EAA2B;AAC1D,EAAA,OAAaD,kCAAiB,QAAQ,CAAA;AACxC;AAMA,eAAsB,yBAAA,CACpB,QAAA,EACA,YAAA,GAAuB,CAAA,EACL;AAClB,EAAA,IAAI,CAACC,iBAAAA,CAAiB,QAAQ,CAAA,EAAG;AAC/B,IAAA,MAAM,IAAI,MAAM,yBAAyB,CAAA;AAAA,EAC3C;AAGA,EAAA,MAAM,IAAA,GAAO,MAAYD,gBAAA,CAAA,cAAA,CAAe,QAAQ,CAAA;AAChD,EAAA,MAAM,SAAA,GAAY,IAAI,UAAA,CAAW,IAAI,CAAA;AAGrC,EAAA,MAAM,OAAA,GAAU,kBAAkB,YAAY,CAAA,CAAA;AAC9C,EAAA,MAAM,aAAA,GAAgB,0BAAA,CAA2B,SAAA,EAAW,OAAO,CAAA;AACnE,EAAA,MAAM,YAAA,GAAyBJ,oBAAA,CAAA,YAAA,CAAa,aAAA,EAAe,KAAK,CAAA;AAKhE,EAAA,MAAM,WAAA,GAAcM,aAAA;AAAA,IAClB,IAAI,UAAA,CAAW;AAAA,MACb,GAAG,IAAI,WAAA,EAAY,CAAE,OAAO,iBAAiB,CAAA;AAAA,MAC7C,GAAG;AAAA,KACJ;AAAA,GACH;AACA,EAAA,MAAM,iBAAiBC,kBAAA,CAAQ,kBAAA,CAAmB,MAAA,CAAO,IAAA,CAAK,WAAW,CAAC,CAAA;AAE1E,EAAA,OAAO;AAAA,IACL,aAAA,EAAe,KAAK,MAAA,CAAO,IAAA,CAAK,aAAa,CAAA,CAAE,QAAA,CAAS,KAAK,CAAC,CAAA,CAAA;AAAA,IAC9D,YAAA,EAAc,KAAK,MAAA,CAAO,IAAA,CAAK,YAAY,CAAA,CAAE,QAAA,CAAS,KAAK,CAAC,CAAA,CAAA;AAAA,IAC5D,gBAAA,EAAkB,eAAe,MAAA,EAAO;AAAA,IACxC,gBAAA,EAAkB,eAAe,SAAA;AAAU,GAC7C;AACF;AAMO,SAAS,+BACd,aAAA,EACS;AAET,EAAA,MAAM,aAAA,GAAgB,aAAA,CAAc,OAAA,CAAQ,KAAA,EAAO,EAAE,CAAA;AACrD,EAAA,MAAM,eAAA,GAAkB,MAAA,CAAO,IAAA,CAAK,aAAA,EAAe,KAAK,CAAA;AAExD,EAAA,IAAI,eAAA,CAAgB,WAAW,EAAA,EAAI;AACjC,IAAA,MAAM,IAAI,MAAM,4BAA4B,CAAA;AAAA,EAC9C;AAGA,EAAA,MAAM,YAAA,GAAyBP,oBAAA,CAAA,YAAA,CAAa,eAAA,EAAiB,KAAK,CAAA;AAGlE,EAAA,MAAM,WAAA,GAAcM,aAAA;AAAA,IAClB,IAAI,UAAA,CAAW;AAAA,MACb,GAAG,IAAI,WAAA,EAAY,CAAE,OAAO,iBAAiB,CAAA;AAAA,MAC7C,GAAG;AAAA,KACJ;AAAA,GACH;AACA,EAAA,MAAM,iBAAiBC,kBAAA,CAAQ,kBAAA,CAAmB,MAAA,CAAO,IAAA,CAAK,WAAW,CAAC,CAAA;AAE1E,EAAA,OAAO;AAAA,IACL,aAAA,EAAe,KAAK,aAAa,CAAA,CAAA;AAAA,IACjC,YAAA,EAAc,KAAK,MAAA,CAAO,IAAA,CAAK,YAAY,CAAA,CAAE,QAAA,CAAS,KAAK,CAAC,CAAA,CAAA;AAAA,IAC5D,gBAAA,EAAkB,eAAe,MAAA,EAAO;AAAA,IACxC,gBAAA,EAAkB,eAAe,SAAA;AAAU,GAC7C;AACF;AAKO,SAAS,qBAAA,GAAiC;AAC/C,EAAA,MAAM,WAAWJ,iBAAAA,EAAiB;AAElC,EAAA,MAAM,IAAA,GAAaC,oCAAmB,QAAQ,CAAA;AAC9C,EAAA,MAAM,SAAA,GAAY,IAAI,UAAA,CAAW,IAAI,CAAA;AAErC,EAAA,MAAM,OAAA,GAAU,CAAA,gBAAA,CAAA;AAChB,EAAA,MAAM,aAAA,GAAgB,0BAAA,CAA2B,SAAA,EAAW,OAAO,CAAA;AACnE,EAAA,MAAM,YAAA,GAAyBJ,oBAAA,CAAA,YAAA,CAAa,aAAA,EAAe,KAAK,CAAA;AAEhE,EAAA,MAAM,WAAA,GAAcM,aAAA;AAAA,IAClB,IAAI,UAAA,CAAW;AAAA,MACb,GAAG,IAAI,WAAA,EAAY,CAAE,OAAO,iBAAiB,CAAA;AAAA,MAC7C,GAAG;AAAA,KACJ;AAAA,GACH;AACA,EAAA,MAAM,iBAAiBC,kBAAA,CAAQ,kBAAA,CAAmB,MAAA,CAAO,IAAA,CAAK,WAAW,CAAC,CAAA;AAE1E,EAAA,OAAO;AAAA,IACL,aAAA,EAAe,KAAK,MAAA,CAAO,IAAA,CAAK,aAAa,CAAA,CAAE,QAAA,CAAS,KAAK,CAAC,CAAA,CAAA;AAAA,IAC9D,YAAA,EAAc,KAAK,MAAA,CAAO,IAAA,CAAK,YAAY,CAAA,CAAE,QAAA,CAAS,KAAK,CAAC,CAAA,CAAA;AAAA,IAC5D,gBAAA,EAAkB,eAAe,MAAA,EAAO;AAAA,IACxC,gBAAA,EAAkB,eAAe,SAAA;AAAU,GAC7C;AACF;AAKO,SAAS,cAAc,OAAA,EAA8B;AAC1D,EAAA,MAAM,cAAA,GAAiB,OAAO,IAAA,CAAK,OAAA,CAAQ,aAAa,OAAA,CAAQ,KAAA,EAAO,EAAE,CAAA,EAAG,KAAK,CAAA;AACjF,EAAA,OAAO,sBAAsB,cAAc,CAAA;AAC7C;AAKO,SAAS,kBAAkB,OAAA,EAAkC;AAClE,EAAA,OAAO,OAAA,CAAQ,gBAAA;AACjB;AAKO,SAAS,gBAAA,CACd,SACA,SAAA,EACS;AACT,EAAA,MAAM,cAAA,GAAiB,OAAO,IAAA,CAAK,SAAA,CAAU,QAAQ,KAAA,EAAO,EAAE,GAAG,KAAK,CAAA;AACtE,EAAA,MAAM,cAAA,GAAiB,sBAAsB,cAAc,CAAA;AAC3D,EAAA,OAAO,cAAA,CAAe,WAAA,EAAY,KAAM,OAAA,CAAQ,WAAA,EAAY;AAC9D;AAKO,SAAS,oBAAA,CACd,SACA,SAAA,EACS;AACT,EAAA,OAAO,OAAA,KAAY,SAAA;AACrB;;;AClQO,IAAM,QAAA,GAA+C;AAAA,EAC1D,OAAA,EAAS;AAAA,IACP,IAAA,EAAM,SAAA;AAAA,IACN,MAAA,EAAQ,qCAAA;AAAA,IACR,UAAA,EAAY,qCAAA;AAAA,IACZ,aAAA,EAAe,qCAAA;AAAA,IACf,iBAAA,EAAmB,mCAAA;AAAA,IACnB,OAAA,EAAS,OAAA;AAAA;AAAA,IACT,cAAA,EAAgB;AAAA,MACd,IAAA,EAAM,gBAAA;AAAA,MACN,MAAA,EAAQ,KAAA;AAAA,MACR,QAAA,EAAU;AAAA;AACZ,GACF;AAAA,EACA,OAAA,EAAS;AAAA,IACP,IAAA,EAAM,SAAA;AAAA,IACN,MAAA,EAAQ,6BAAA;AAAA,IACR,UAAA,EAAY,6BAAA;AAAA,IACZ,aAAA,EAAe,6BAAA;AAAA,IACf,iBAAA,EAAmB,gDAAA;AAAA,IACnB,OAAA,EAAS,OAAA;AAAA;AAAA,IACT,cAAA,EAAgB;AAAA,MACd,IAAA,EAAM,gBAAA;AAAA,MACN,MAAA,EAAQ,KAAA;AAAA,MACR,QAAA,EAAU;AAAA;AACZ,GACF;AAAA,EACA,KAAA,EAAO;AAAA,IACL,IAAA,EAAM,OAAA;AAAA,IACN,MAAA,EAAQ,uBAAA;AAAA,IACR,UAAA,EAAY,uBAAA;AAAA,IACZ,aAAA,EAAe,uBAAA;AAAA,IACf,iBAAA,EAAmB,oCAAA;AAAA,IACnB,OAAA,EAAS,OAAA;AAAA;AAAA,IACT,cAAA,EAAgB;AAAA,MACd,IAAA,EAAM,gBAAA;AAAA,MACN,MAAA,EAAQ,KAAA;AAAA,MACR,QAAA,EAAU;AAAA;AACZ;AAEJ,CAAA;;;AC7CUC,oBAAA,CAAA,GAAA,CAAI,cAAA,GAAiB,CAAC,CAAA,EAAA,GAAM,CAAA,KACpCT,SAAAA,CAAKO,aAAAA,EAAQ,CAAA,EAAaE,oBAAA,CAAA,GAAA,CAAI,WAAA,CAAY,GAAG,CAAC,CAAC,CAAA;AAM1C,IAAM,YAAN,MAAgB;AAAA,EACb,UAAA;AAAA,EACQ,OAAA;AAAA,EAEhB,YAAY,OAAA,EAAkB;AAC5B,IAAA,IAAA,CAAK,aAAa,MAAA,CAAO,IAAA;AAAA,MACvB,OAAA,CAAQ,aAAA,CAAc,OAAA,CAAQ,KAAA,EAAO,EAAE,CAAA;AAAA,MACvC;AAAA,KACF;AACA,IAAA,IAAA,CAAK,OAAA,GAAU,cAAc,OAAO,CAAA;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,IAAA,EAAuD;AAC9D,IAAA,MAAM,SAAA,GAAsBA,oBAAA,CAAA,IAAA,CAAK,IAAA,EAAM,IAAA,CAAK,UAAU,CAAA;AACtD,IAAA,MAAM,CAAA,GAAI,UAAU,CAAA,CAAE,QAAA,CAAS,EAAE,CAAA,CAAE,QAAA,CAAS,IAAI,GAAG,CAAA;AACnD,IAAA,MAAM,CAAA,GAAI,UAAU,CAAA,CAAE,QAAA,CAAS,EAAE,CAAA,CAAE,QAAA,CAAS,IAAI,GAAG,CAAA;AAKnD,IAAA,MAAM,CAAA,GAAI,UAAU,QAAA,GAAW,EAAA;AAE/B,IAAA,OAAO,EAAE,GAAG,CAAA,EAAA,EAAK,CAAC,IAAI,CAAA,EAAG,CAAA,EAAA,EAAK,CAAC,CAAA,CAAA,EAAI,CAAA,EAAE;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,OAAA,EAAyB;AACnC,IAAA,MAAM,YAAA,GAAe,IAAI,WAAA,EAAY,CAAE,OAAO,OAAO,CAAA;AACrD,IAAA,MAAM,MAAA,GAAS,IAAI,WAAA,EAAY,CAAE,MAAA;AAAA,MAC/B,CAAA;AAAA,EAAiC,aAAa,MAAM,CAAA;AAAA,KACtD;AACA,IAAA,MAAM,eAAA,GAAkB,IAAI,UAAA,CAAW,CAAC,GAAG,MAAA,EAAQ,GAAG,YAAY,CAAC,CAAA;AACnE,IAAA,MAAM,IAAA,GAAOP,gBAAW,eAAe,CAAA;AAEvC,IAAA,MAAM,EAAE,CAAA,EAAG,CAAA,EAAG,GAAE,GAAI,IAAA,CAAK,SAAS,IAAI,CAAA;AACtC,IAAA,OAAO,CAAA,EAAG,CAAC,CAAA,EAAG,CAAA,CAAE,MAAM,CAAC,CAAC,CAAA,EAAG,CAAA,CAAE,SAAS,EAAE,CAAA,CAAE,QAAA,CAAS,CAAA,EAAG,GAAG,CAAC,CAAA,CAAA;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA,EAKA,aAAA,CACE,MAAA,EACA,KAAA,EACA,KAAA,EACQ;AAGR,IAAA,MAAM,eAAA,GAAkB,IAAA,CAAK,UAAA,CAAW,cAAA,EAAgB,MAAA,EAAQ;AAAA,MAC9D,YAAA,EAAc;AAAA,QACZ,EAAE,IAAA,EAAM,MAAA,EAAQ,IAAA,EAAM,QAAA,EAAS;AAAA,QAC/B,EAAE,IAAA,EAAM,SAAA,EAAW,IAAA,EAAM,QAAA,EAAS;AAAA,QAClC,EAAE,IAAA,EAAM,SAAA,EAAW,IAAA,EAAM,SAAA,EAAU;AAAA,QACnC,EAAE,IAAA,EAAM,mBAAA,EAAqB,IAAA,EAAM,SAAA;AAAU;AAC/C,KACD,CAAA;AAED,IAAA,MAAM,WAAA,GAAc,OAAO,IAAA,CAAK,KAAK,EAAE,IAAA,CAAK,CAAC,CAAA,KAAM,CAAA,KAAM,cAAc,CAAA;AACvE,IAAA,IAAI,CAAC,WAAA,EAAa;AAChB,MAAA,MAAM,IAAI,MAAM,uBAAuB,CAAA;AAAA,IACzC;AAEA,IAAA,MAAM,UAAA,GAAa,IAAA,CAAK,UAAA,CAAW,WAAA,EAAa,OAAO,KAAK,CAAA;AAE5D,IAAA,MAAM,WAAA,GAAcA,eAAAA;AAAA,MAClB,IAAI,WAAW,CAAC,EAAA,EAAM,GAAM,GAAG,eAAA,EAAiB,GAAG,UAAU,CAAC;AAAA,KAChE;AAEA,IAAA,MAAM,EAAE,CAAA,EAAG,CAAA,EAAG,GAAE,GAAI,IAAA,CAAK,SAAS,WAAW,CAAA;AAC7C,IAAA,OAAO,CAAA,EAAG,CAAC,CAAA,EAAG,CAAA,CAAE,MAAM,CAAC,CAAC,CAAA,EAAG,CAAA,CAAE,SAAS,EAAE,CAAA,CAAE,QAAA,CAAS,CAAA,EAAG,GAAG,CAAC,CAAA,CAAA;AAAA,EAC5D;AAAA,EAEQ,UAAA,CACN,QAAA,EACA,IAAA,EACA,KAAA,EACY;AACZ,IAAA,MAAM,QAAA,GAAWA,eAAAA;AAAA,MACf,IAAI,aAAY,CAAE,MAAA,CAAO,KAAK,UAAA,CAAW,QAAA,EAAU,KAAK,CAAC;AAAA,KAC3D;AACA,IAAA,MAAM,WAAA,GAAc,IAAA,CAAK,UAAA,CAAW,QAAA,EAAU,MAAM,KAAK,CAAA;AACzD,IAAA,OAAOA,eAAAA,CAAW,IAAI,UAAA,CAAW,CAAC,GAAG,QAAA,EAAU,GAAG,WAAW,CAAC,CAAC,CAAA;AAAA,EACjE;AAAA,EAEQ,UAAA,CACN,aACA,KAAA,EACQ;AACR,IAAA,MAAM,MAAA,GAAS,MAAM,WAAW,CAAA;AAChC,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,OAAO,WAAA;AAAA,IACT;AAEA,IAAA,MAAM,SAAA,GAAY,MAAA,CAAO,GAAA,CAAI,CAAC,MAAM,CAAA,EAAG,CAAA,CAAE,IAAI,CAAA,CAAA,EAAI,CAAA,CAAE,IAAI,CAAA,CAAE,CAAA,CAAE,KAAK,GAAG,CAAA;AACnE,IAAA,OAAO,CAAA,EAAG,WAAW,CAAA,CAAA,EAAI,SAAS,CAAA,CAAA,CAAA;AAAA,EACpC;AAAA,EAEQ,UAAA,CACN,QAAA,EACA,IAAA,EACA,KAAA,EACY;AACZ,IAAA,MAAM,MAAA,GAAS,MAAM,QAAQ,CAAA;AAC7B,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,cAAA,EAAiB,QAAQ,CAAA,CAAE,CAAA;AAAA,IAC7C;AAEA,IAAA,MAAM,QAAsB,EAAC;AAE7B,IAAA,KAAA,MAAW,SAAS,MAAA,EAAQ;AAC1B,MAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,IAAI,CAAA;AAC7B,MAAA,KAAA,CAAM,KAAK,IAAA,CAAK,WAAA,CAAY,MAAM,IAAA,EAAM,KAAA,EAAO,KAAK,CAAC,CAAA;AAAA,IACvD;AAEA,IAAA,OAAO,IAAI,UAAA,CAAW,KAAA,CAAM,OAAA,CAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAA;AAAA,EACpD;AAAA,EAEQ,WAAA,CACN,IAAA,EACA,KAAA,EACA,KAAA,EACY;AACZ,IAAA,IAAI,SAAS,QAAA,EAAU;AACrB,MAAA,OAAOA,gBAAW,IAAI,WAAA,EAAY,CAAE,MAAA,CAAO,KAAe,CAAC,CAAA;AAAA,IAC7D;AAEA,IAAA,IAAI,SAAS,OAAA,EAAS;AACpB,MAAA,MAAM,KAAA,GAAQ,OAAO,IAAA,CAAM,KAAA,CAAiB,QAAQ,KAAA,EAAO,EAAE,GAAG,KAAK,CAAA;AACrE,MAAA,OAAOA,gBAAW,KAAK,CAAA;AAAA,IACzB;AAEA,IAAA,IAAI,SAAS,SAAA,EAAW;AACtB,MAAA,MAAM,OAAQ,KAAA,CAAiB,OAAA,CAAQ,KAAA,EAAO,EAAE,EAAE,WAAA,EAAY;AAC9D,MAAA,MAAM,MAAA,GAAS,IAAI,UAAA,CAAW,EAAE,CAAA;AAChC,MAAA,MAAM,SAAA,GAAY,MAAA,CAAO,IAAA,CAAK,IAAA,EAAM,KAAK,CAAA;AACzC,MAAA,MAAA,CAAO,GAAA,CAAI,SAAA,EAAW,EAAA,GAAK,SAAA,CAAU,MAAM,CAAA;AAC3C,MAAA,OAAO,MAAA;AAAA,IACT;AAEA,IAAA,IAAI,KAAK,UAAA,CAAW,MAAM,KAAK,IAAA,CAAK,UAAA,CAAW,KAAK,CAAA,EAAG;AACrD,MAAA,MAAM,GAAA,GAAM,OAAO,KAAiC,CAAA;AACpD,MAAA,MAAM,KAAA,GAAQ,IAAI,UAAA,CAAW,EAAE,CAAA;AAC/B,MAAA,IAAI,GAAA,GAAM,GAAA;AACV,MAAA,KAAA,IAAS,CAAA,GAAI,EAAA,EAAI,CAAA,IAAK,CAAA,EAAG,CAAA,EAAA,EAAK;AAC5B,QAAA,KAAA,CAAM,CAAC,CAAA,GAAI,MAAA,CAAO,GAAA,GAAM,MAAA,CAAO,GAAI,CAAC,CAAA;AACpC,QAAA,GAAA,GAAM,GAAA,IAAO,OAAO,CAAC,CAAA;AAAA,MACvB;AACA,MAAA,OAAO,KAAA;AAAA,IACT;AAEA,IAAA,IAAI,SAAS,MAAA,EAAQ;AACnB,MAAA,MAAM,KAAA,GAAQ,IAAI,UAAA,CAAW,EAAE,CAAA;AAC/B,MAAA,KAAA,CAAM,EAAE,CAAA,GAAI,KAAA,GAAQ,CAAA,GAAI,CAAA;AACxB,MAAA,OAAO,KAAA;AAAA,IACT;AAEA,IAAA,IAAI,KAAA,CAAM,IAAI,CAAA,EAAG;AACf,MAAA,OAAO,IAAA,CAAK,UAAA,CAAW,IAAA,EAAM,KAAA,EAAkC,KAAK,CAAA;AAAA,IACtE;AAEA,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,kBAAA,EAAqB,IAAI,CAAA,CAAE,CAAA;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB,EAAA,EAA4B;AAE1C,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,oBAAA,CAAqB,EAAE,CAAA;AAC9C,IAAA,MAAM,IAAA,GAAOA,gBAAW,SAAS,CAAA;AAEjC,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,QAAA,CAAS,IAAI,CAAA;AAGpC,IAAA,MAAM,IAAI,EAAA,CAAG,OAAA,GAAU,CAAA,GAAI,EAAA,IAAM,UAAU,CAAA,GAAI,EAAA,CAAA;AAG/C,IAAA,OAAO,IAAA,CAAK,2BAA2B,EAAA,EAAI;AAAA,MACzC,GAAG,SAAA,CAAU,CAAA;AAAA,MACb,GAAG,SAAA,CAAU,CAAA;AAAA,MACb;AAAA,KACD,CAAA;AAAA,EACH;AAAA,EAEQ,qBAAqB,EAAA,EAAgC;AAG3D,IAAA,MAAM,KAAA,GAA0D;AAAA,MAC9D,EAAA,CAAG,KAAA;AAAA,MACH,EAAA,CAAG,QAAA;AAAA,MACH,EAAA,CAAG,QAAA;AAAA,MACH,GAAG,EAAA,IAAM,EAAA;AAAA,MACT,EAAA,CAAG,KAAA;AAAA,MACH,EAAA,CAAG,IAAA;AAAA,MACH,EAAA,CAAG,OAAA;AAAA,MACH,CAAA;AAAA,MACA;AAAA,KACF;AAEA,IAAA,OAAO,IAAA,CAAK,UAAU,KAAK,CAAA;AAAA,EAC7B;AAAA,EAEQ,0BAAA,CACN,IACA,GAAA,EACQ;AACR,IAAA,MAAM,KAAA,GAA0D;AAAA,MAC9D,EAAA,CAAG,KAAA;AAAA,MACH,EAAA,CAAG,QAAA;AAAA,MACH,EAAA,CAAG,QAAA;AAAA,MACH,GAAG,EAAA,IAAM,EAAA;AAAA,MACT,EAAA,CAAG,KAAA;AAAA,MACH,EAAA,CAAG,IAAA;AAAA,MACH,GAAA,CAAI,CAAA;AAAA,MACJ,GAAA,CAAI,CAAA;AAAA,MACJ,GAAA,CAAI;AAAA,KACN;AAEA,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,SAAA,CAAU,KAAK,CAAA;AACpC,IAAA,OAAO,OAAO,MAAA,CAAO,IAAA,CAAK,OAAO,CAAA,CAAE,SAAS,KAAK,CAAA;AAAA,EACnD;AAAA,EAEQ,UACN,KAAA,EACY;AACZ,IAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,EAAG;AACxB,MAAA,MAAM,YAAA,GAAe,MAAM,GAAA,CAAI,CAAC,SAAS,IAAA,CAAK,SAAA,CAAU,IAAI,CAAC,CAAA;AAC7D,MAAA,MAAM,WAAA,GAAc,aAAa,MAAA,CAAO,CAAC,KAAK,IAAA,KAAS,GAAA,GAAM,IAAA,CAAK,MAAA,EAAQ,CAAC,CAAA;AAC3E,MAAA,MAAM,SAAA,GAAY,aAAa,OAAA,CAAQ,CAAC,SAAS,KAAA,CAAM,IAAA,CAAK,IAAI,CAAC,CAAA;AAEjE,MAAA,IAAI,cAAc,EAAA,EAAI;AACpB,QAAA,OAAO,IAAI,UAAA,CAAW,CAAC,MAAO,WAAA,EAAa,GAAG,SAAS,CAAC,CAAA;AAAA,MAC1D,CAAA,MAAO;AACL,QAAA,MAAMQ,YAAAA,GAAc,IAAA,CAAK,eAAA,CAAgB,WAAW,CAAA;AACpD,QAAA,OAAO,IAAI,UAAA,CAAW;AAAA,UACpB,MAAOA,YAAAA,CAAY,MAAA;AAAA,UACnB,GAAG,KAAA,CAAM,IAAA,CAAKA,YAAW,CAAA;AAAA,UACzB,GAAG;AAAA,SACJ,CAAA;AAAA,MACH;AAAA,IACF;AAEA,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,OAAA,CAAQ,KAAK,CAAA;AAEhC,IAAA,IAAI,MAAM,MAAA,KAAW,CAAA,IAAK,KAAA,CAAM,CAAC,IAAI,GAAA,EAAM;AACzC,MAAA,OAAO,KAAA;AAAA,IACT;AAEA,IAAA,IAAI,KAAA,CAAM,SAAS,EAAA,EAAI;AACrB,MAAA,OAAO,IAAI,UAAA,CAAW,CAAC,GAAA,GAAO,KAAA,CAAM,MAAA,EAAQ,GAAG,KAAA,CAAM,IAAA,CAAK,KAAK,CAAC,CAAC,CAAA;AAAA,IACnE;AAEA,IAAA,MAAM,WAAA,GAAc,IAAA,CAAK,eAAA,CAAgB,KAAA,CAAM,MAAM,CAAA;AACrD,IAAA,OAAO,IAAI,UAAA,CAAW,CAAC,GAAA,GAAO,WAAA,CAAY,QAAQ,GAAG,KAAA,CAAM,IAAA,CAAK,WAAW,GAAG,GAAG,KAAA,CAAM,IAAA,CAAK,KAAK,CAAC,CAAC,CAAA;AAAA,EACrG;AAAA,EAEQ,QACN,KAAA,EACY;AACZ,IAAA,IAAI,KAAA,KAAU,QAAQ,KAAA,KAAU,EAAA,IAAM,UAAU,CAAA,IAAK,KAAA,KAAU,MAAA,CAAO,CAAC,CAAA,EAAG;AACxE,MAAA,OAAO,IAAI,WAAW,CAAC,CAAA;AAAA,IACzB;AAEA,IAAA,IAAI,iBAAiB,UAAA,EAAY;AAC/B,MAAA,OAAO,KAAA;AAAA,IACT;AAEA,IAAA,IAAI,OAAO,UAAU,QAAA,EAAU;AAC7B,MAAA,IAAI,KAAA,CAAM,UAAA,CAAW,IAAI,CAAA,EAAG;AAC1B,QAAA,MAAM,GAAA,GAAM,KAAA,CAAM,KAAA,CAAM,CAAC,CAAA;AACzB,QAAA,IAAI,GAAA,CAAI,WAAW,CAAA,EAAG;AACpB,UAAA,OAAO,IAAI,WAAW,CAAC,CAAA;AAAA,QACzB;AACA,QAAA,OAAO,MAAA,CAAO,IAAA,CAAK,GAAA,CAAI,QAAA,CAAS,GAAA,CAAI,MAAA,GAAU,GAAA,CAAI,MAAA,GAAS,CAAA,EAAI,GAAG,CAAA,EAAG,KAAK,CAAA;AAAA,MAC5E;AACA,MAAA,OAAO,IAAI,WAAA,EAAY,CAAE,MAAA,CAAO,KAAK,CAAA;AAAA,IACvC;AAEA,IAAA,IAAI,OAAO,KAAA,KAAU,QAAA,IAAY,OAAO,UAAU,QAAA,EAAU;AAC1D,MAAA,OAAO,IAAA,CAAK,gBAAgB,KAAK,CAAA;AAAA,IACnC;AAEA,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,eAAA,EAAkB,KAAK,CAAA,CAAE,CAAA;AAAA,EAC3C;AAAA,EAEQ,gBAAgB,KAAA,EAAoC;AAC1D,IAAA,IAAI,KAAA,KAAU,CAAA,IAAK,KAAA,KAAU,MAAA,CAAO,CAAC,CAAA,EAAG;AACtC,MAAA,OAAO,IAAI,WAAW,CAAC,CAAA;AAAA,IACzB;AAEA,IAAA,MAAM,QAAkB,EAAC;AACzB,IAAA,IAAI,CAAA,GAAI,OAAO,KAAK,CAAA;AAEpB,IAAA,OAAO,IAAI,CAAA,EAAG;AACZ,MAAA,KAAA,CAAM,QAAQ,MAAA,CAAO,CAAA,GAAI,MAAA,CAAO,GAAI,CAAC,CAAC,CAAA;AACtC,MAAA,CAAA,GAAI,CAAA,IAAK,OAAO,CAAC,CAAA;AAAA,IACnB;AAEA,IAAA,OAAO,IAAI,WAAW,KAAK,CAAA;AAAA,EAC7B;AACF;AAMO,IAAM,gBAAN,MAAoB;AAAA,EACjB,OAAA;AAAA,EACQ,SAAA;AAAA,EAEhB,YAAY,OAAA,EAAkB;AAC5B,IAAA,IAAA,CAAK,OAAA,GAAUF,kBAAAA,CAAQ,UAAA,CAAW,OAAA,CAAQ,gBAAgB,CAAA;AAC1D,IAAA,IAAA,CAAK,SAAA,GAAY,IAAA,CAAK,OAAA,CAAQ,SAAA,EAAU;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKA,eAAA,CACE,aACA,kBAAA,EACa;AACb,IAAA,WAAA,CAAY,IAAA,CAAK,KAAK,OAAO,CAAA;AAC7B,IAAA,OAAO,WAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,IAAA,EAA8B;AACrC,IAAA,OAAO,KAAK,OAAA,CAAQ,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,IAAI,CAAC,CAAA;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA,EAKA,eAAA,CAAgB,MAAkB,SAAA,EAAgC;AAChE,IAAA,OAAO,IAAA,CAAK,OAAA,CAAQ,MAAA,CAAO,MAAA,CAAO,IAAA,CAAK,IAAI,CAAA,EAAG,MAAA,CAAO,IAAA,CAAK,SAAS,CAAC,CAAA;AAAA,EACtE;AAAA;AAAA;AAAA;AAAA,EAKA,aAAA,CACE,KAAA,EACA,iBAAA,EACA,gBAAA,EAC+B;AAE/B,IAAA,MAAM,cAAcG,cAAA,CAAI,yBAAA,CAA0B,OAAA,CAAQ,KAAA,CAAM,OAAO,CAAA;AAGvE,IAAA,MAAM,WAAA,GAAc,YAAY,WAAA,EAAY;AAE5C,IAAA,IAAI,WAAA,CAAY,MAAA,EAAO,CAAE,KAAA,KAAU,CAAA,EAAG;AAEpC,MAAA,OAAO,WAAA;AAAA,IACT;AAGA,IAAA,MAAM,kBAAA,GAAqB,YAAY,OAAA,EAAQ;AAG/C,IAAA,MAAM,QAAA,GAAWA,eAAI,cAAA,CAAe,gCAAA;AAAA,MAClC,IAAIA,eAAI,kCAAA,CAAmC;AAAA,QACzC,SAAA,EAAW,MAAA,CAAO,IAAA,CAAKJ,aAAAA,CAAO,IAAI,aAAY,CAAE,MAAA,CAAO,iBAAiB,CAAC,CAAC,CAAA;AAAA,QAC1E,KAAA,EAAO,mBAAmB,KAAA,EAAM;AAAA,QAChC,yBAAA,EAA2B,gBAAA;AAAA,QAC3B,UAAA,EAAY,YAAY,cAAA;AAAe,OACxC;AAAA,KACH;AAEA,IAAA,MAAM,YAAA,GAAeA,aAAAA,CAAO,QAAA,CAAS,KAAA,EAAO,CAAA;AAC5C,IAAA,MAAM,YAAY,IAAA,CAAK,OAAA,CAAQ,KAAK,MAAA,CAAO,IAAA,CAAK,YAAY,CAAC,CAAA;AAG7D,IAAA,MAAM,cAAA,GAAiB,IAAII,cAAA,CAAI,yBAAA,CAA0B;AAAA,MACvD,OAAA,EAAS,mBAAmB,OAAA,EAAQ;AAAA,MACpC,KAAA,EAAO,mBAAmB,KAAA,EAAM;AAAA,MAChC,yBAAA,EAA2B,gBAAA;AAAA,MAC3B,SAAA,EAAWA,cAAA,CAAI,KAAA,CAAM,MAAA,CAAO;AAAA,QAC1BA,cAAA,CAAI,MAAM,MAAA,CAAO;AAAA,UACf,IAAIA,eAAI,UAAA,CAAW;AAAA,YACjB,GAAA,EAAKA,cAAA,CAAI,KAAA,CAAM,SAAA,CAAU,YAAY,CAAA;AAAA,YACrC,KAAKA,cAAA,CAAI,KAAA,CAAM,SAAS,IAAA,CAAK,OAAA,CAAQ,cAAc;AAAA,WACpD,CAAA;AAAA,UACD,IAAIA,eAAI,UAAA,CAAW;AAAA,YACjB,GAAA,EAAKA,cAAA,CAAI,KAAA,CAAM,SAAA,CAAU,WAAW,CAAA;AAAA,YACpC,GAAA,EAAKA,cAAA,CAAI,KAAA,CAAM,QAAA,CAAS,SAAS;AAAA,WAClC;AAAA,SACF;AAAA,OACF;AAAA,KACF,CAAA;AAED,IAAA,WAAA,CAAY,WAAA,CAAYA,cAAA,CAAI,kBAAA,CAAmB,yBAAA,CAA0B,cAAc,CAAC,CAAA;AAExF,IAAA,OAAO,WAAA;AAAA,EACT;AACF;AAKO,IAAM,YAAN,MAAgB;AAAA,EACL,SAAA;AAAA,EACA,aAAA;AAAA,EACA,OAAA;AAAA,EACA,OAAA;AAAA,EAEhB,WAAA,CAAY,OAAA,EAAkB,OAAA,GAAuB,SAAA,EAAW;AAC9D,IAAA,IAAA,CAAK,OAAA,GAAU,OAAA;AACf,IAAA,IAAA,CAAK,OAAA,GAAU,SAAS,OAAO,CAAA;AAC/B,IAAA,IAAA,CAAK,SAAA,GAAY,IAAI,SAAA,CAAU,OAAO,CAAA;AACtC,IAAA,IAAA,CAAK,aAAA,GAAgB,IAAI,aAAA,CAAc,OAAO,CAAA;AAAA,EAChD;AAAA,EAEA,IAAI,UAAA,GAAyB;AAC3B,IAAA,OAAO,KAAK,SAAA,CAAU,OAAA;AAAA,EACxB;AAAA,EAEA,IAAI,cAAA,GAAyB;AAC3B,IAAA,OAAO,KAAK,aAAA,CAAc,SAAA;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKA,mBAAmB,EAAA,EAA4B;AAC7C,IAAA,OAAO,IAAA,CAAK,SAAA,CAAU,eAAA,CAAgB,EAAE,CAAA;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKA,uBAAuB,WAAA,EAAuC;AAC5D,IAAA,OAAO,KAAK,aAAA,CAAc,eAAA;AAAA,MACxB,WAAA;AAAA,MACA,KAAK,OAAA,CAAQ;AAAA,KACf;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,OAAA,EAAyB;AACnC,IAAA,OAAO,IAAA,CAAK,SAAA,CAAU,WAAA,CAAY,OAAO,CAAA;AAAA,EAC3C;AACF","file":"index.js","sourcesContent":["/**\n * TVA Protocol Key Management\n *\n * Handles the dual-key architecture required for TVA Protocol:\n * - secp256k1 keys for EVM compatibility (MetaMask signing)\n * - Ed25519 keys for Stellar transaction submission\n *\n * Keys are derived deterministically so users can recover both\n * key types from a single mnemonic phrase.\n */\n\nimport { Keypair, StrKey } from '@stellar/stellar-sdk';\nimport * as bip39 from 'bip39';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { keccak_256 } from '@noble/hashes/sha3';\nimport * as secp256k1 from '@noble/secp256k1';\nimport * as ed25519 from '@noble/ed25519';\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha512 } from '@noble/hashes/sha512';\nimport type { KeyPair, EvmAddress, StellarAddress } from '../types/index.js';\n\n// Enable synchronous methods for ed25519 (required for node.js)\ned25519.etc.sha512Sync = (...m) => sha512(ed25519.etc.concatBytes(...m));\n\n/**\n * Derives a secp256k1 key from seed using BIP32 derivation\n */\nfunction deriveSecp256k1KeyFromSeed(\n  seed: Uint8Array,\n  path: string\n): Uint8Array {\n  // Master key derivation for Bitcoin-style keys\n  const I = hmac(sha512, new TextEncoder().encode('Bitcoin seed'), seed);\n  let key = new Uint8Array(I.slice(0, 32));\n  let chainCode = new Uint8Array(I.slice(32));\n\n  // Parse path\n  const segments = path\n    .replace(/^m\\//, '')\n    .split('/')\n    .map((s) => {\n      const hardened = s.endsWith(\"'\");\n      const index = parseInt(s.replace(\"'\", ''), 10);\n      return { index, hardened };\n    });\n\n  for (const segment of segments) {\n    const indexBuffer = new Uint8Array(4);\n    const view = new DataView(indexBuffer.buffer);\n\n    let data: Uint8Array;\n    if (segment.hardened) {\n      const hardenedIndex = segment.index | 0x80000000;\n      view.setUint32(0, hardenedIndex, false);\n      data = new Uint8Array(1 + 32 + 4);\n      data[0] = 0x00;\n      data.set(key, 1);\n      data.set(indexBuffer, 33);\n    } else {\n      view.setUint32(0, segment.index, false);\n      const publicKey = secp256k1.getPublicKey(key, true);\n      data = new Uint8Array(33 + 4);\n      data.set(publicKey, 0);\n      data.set(indexBuffer, 33);\n    }\n\n    const I2 = hmac(sha512, chainCode, data);\n    const IL = new Uint8Array(I2.slice(0, 32));\n    chainCode = new Uint8Array(I2.slice(32));\n\n    // Child key = parse256(IL) + parent key (mod n)\n    const parentKeyBigInt = bytesToBigInt(key);\n    const ILBigInt = bytesToBigInt(IL);\n    const n = BigInt(\n      '0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141'\n    );\n    const childKeyBigInt = (ILBigInt + parentKeyBigInt) % n;\n    key = bigIntToBytes(childKeyBigInt, 32);\n  }\n\n  return key;\n}\n\nfunction bytesToBigInt(bytes: Uint8Array): bigint {\n  let result = BigInt(0);\n  for (let i = 0; i < bytes.length; i++) {\n    result = (result << BigInt(8)) | BigInt(bytes[i]);\n  }\n  return result;\n}\n\nfunction bigIntToBytes(value: bigint, length: number): Uint8Array<ArrayBuffer> {\n  const result = new Uint8Array(length);\n  let v = value;\n  for (let i = length - 1; i >= 0; i--) {\n    result[i] = Number(v & BigInt(0xff));\n    v = v >> BigInt(8);\n  }\n  return result;\n}\n\n/**\n * Converts a secp256k1 public key to an EVM address\n */\nexport function publicKeyToEvmAddress(publicKey: Uint8Array): EvmAddress {\n  // Remove the 0x04 prefix if present (uncompressed key marker)\n  const keyWithoutPrefix =\n    publicKey.length === 65 ? publicKey.slice(1) : publicKey;\n\n  // Keccak256 hash of the public key (x,y coordinates)\n  const hash = keccak_256(keyWithoutPrefix);\n\n  // Take the last 20 bytes\n  const addressBytes = new Uint8Array(hash.slice(-20));\n\n  // Convert to hex string with 0x prefix\n  const hex = Array.from(addressBytes)\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('');\n\n  return `0x${hex}` as EvmAddress;\n}\n\n/**\n * Converts an Ed25519 public key to a Stellar G-address\n */\nexport function publicKeyToStellarAddress(\n  publicKey: Uint8Array\n): StellarAddress {\n  return StrKey.encodeEd25519PublicKey(Buffer.from(publicKey)) as StellarAddress;\n}\n\n/**\n * Converts an Ed25519 secret key to a Stellar S-address (secret)\n */\nexport function secretKeyToStellarSecret(secretKey: Uint8Array): string {\n  return StrKey.encodeEd25519SecretSeed(Buffer.from(secretKey));\n}\n\n/**\n * Generates a new mnemonic phrase\n */\nexport function generateMnemonic(strength: 128 | 256 = 256): string {\n  return bip39.generateMnemonic(strength);\n}\n\n/**\n * Validates a mnemonic phrase\n */\nexport function validateMnemonic(mnemonic: string): boolean {\n  return bip39.validateMnemonic(mnemonic);\n}\n\n/**\n * Derives a full TVA key pair from a mnemonic phrase\n * This creates both the EVM (secp256k1) and Stellar (Ed25519) key pairs\n */\nexport async function deriveKeyPairFromMnemonic(\n  mnemonic: string,\n  accountIndex: number = 0\n): Promise<KeyPair> {\n  if (!validateMnemonic(mnemonic)) {\n    throw new Error('Invalid mnemonic phrase');\n  }\n\n  // Generate seed from mnemonic\n  const seed = await bip39.mnemonicToSeed(mnemonic);\n  const seedArray = new Uint8Array(seed);\n\n  // Derive secp256k1 key for EVM\n  const evmPath = `m/44'/60'/0'/0/${accountIndex}`;\n  const evmPrivateKey = deriveSecp256k1KeyFromSeed(seedArray, evmPath);\n  const evmPublicKey = secp256k1.getPublicKey(evmPrivateKey, false); // uncompressed\n\n  // Derive Ed25519 key for Stellar\n  // Use a deterministic derivation from the EVM private key to ensure\n  // users can always recover their Stellar key from their EVM key\n  const stellarSeed = sha256(\n    new Uint8Array([\n      ...new TextEncoder().encode('TVA-STELLAR-KEY'),\n      ...evmPrivateKey,\n    ])\n  );\n  const stellarKeypair = Keypair.fromRawEd25519Seed(Buffer.from(stellarSeed));\n\n  return {\n    evmPrivateKey: `0x${Buffer.from(evmPrivateKey).toString('hex')}`,\n    evmPublicKey: `0x${Buffer.from(evmPublicKey).toString('hex')}`,\n    stellarSecretKey: stellarKeypair.secret(),\n    stellarPublicKey: stellarKeypair.publicKey(),\n  };\n}\n\n/**\n * Derives a key pair from an existing EVM private key\n * Useful for importing existing Ethereum wallets\n */\nexport function deriveKeyPairFromEvmPrivateKey(\n  evmPrivateKey: string\n): KeyPair {\n  // Remove 0x prefix if present\n  const privateKeyHex = evmPrivateKey.replace(/^0x/, '');\n  const privateKeyBytes = Buffer.from(privateKeyHex, 'hex');\n\n  if (privateKeyBytes.length !== 32) {\n    throw new Error('Invalid private key length');\n  }\n\n  // Get EVM public key\n  const evmPublicKey = secp256k1.getPublicKey(privateKeyBytes, false);\n\n  // Derive Stellar key deterministically from EVM private key\n  const stellarSeed = sha256(\n    new Uint8Array([\n      ...new TextEncoder().encode('TVA-STELLAR-KEY'),\n      ...privateKeyBytes,\n    ])\n  );\n  const stellarKeypair = Keypair.fromRawEd25519Seed(Buffer.from(stellarSeed));\n\n  return {\n    evmPrivateKey: `0x${privateKeyHex}`,\n    evmPublicKey: `0x${Buffer.from(evmPublicKey).toString('hex')}`,\n    stellarSecretKey: stellarKeypair.secret(),\n    stellarPublicKey: stellarKeypair.publicKey(),\n  };\n}\n\n/**\n * Creates a random key pair (for testing or new accounts)\n */\nexport function generateRandomKeyPair(): KeyPair {\n  const mnemonic = generateMnemonic();\n  // Use synchronous version for random generation\n  const seed = bip39.mnemonicToSeedSync(mnemonic);\n  const seedArray = new Uint8Array(seed);\n\n  const evmPath = `m/44'/60'/0'/0/0`;\n  const evmPrivateKey = deriveSecp256k1KeyFromSeed(seedArray, evmPath);\n  const evmPublicKey = secp256k1.getPublicKey(evmPrivateKey, false);\n\n  const stellarSeed = sha256(\n    new Uint8Array([\n      ...new TextEncoder().encode('TVA-STELLAR-KEY'),\n      ...evmPrivateKey,\n    ])\n  );\n  const stellarKeypair = Keypair.fromRawEd25519Seed(Buffer.from(stellarSeed));\n\n  return {\n    evmPrivateKey: `0x${Buffer.from(evmPrivateKey).toString('hex')}`,\n    evmPublicKey: `0x${Buffer.from(evmPublicKey).toString('hex')}`,\n    stellarSecretKey: stellarKeypair.secret(),\n    stellarPublicKey: stellarKeypair.publicKey(),\n  };\n}\n\n/**\n * Gets the EVM address from a key pair\n */\nexport function getEvmAddress(keyPair: KeyPair): EvmAddress {\n  const publicKeyBytes = Buffer.from(keyPair.evmPublicKey.replace(/^0x/, ''), 'hex');\n  return publicKeyToEvmAddress(publicKeyBytes);\n}\n\n/**\n * Gets the Stellar address from a key pair\n */\nexport function getStellarAddress(keyPair: KeyPair): StellarAddress {\n  return keyPair.stellarPublicKey as StellarAddress;\n}\n\n/**\n * Verifies that an EVM address matches a public key\n */\nexport function verifyEvmAddress(\n  address: EvmAddress,\n  publicKey: string\n): boolean {\n  const publicKeyBytes = Buffer.from(publicKey.replace(/^0x/, ''), 'hex');\n  const derivedAddress = publicKeyToEvmAddress(publicKeyBytes);\n  return derivedAddress.toLowerCase() === address.toLowerCase();\n}\n\n/**\n * Verifies that a Stellar address matches a public key\n */\nexport function verifyStellarAddress(\n  address: StellarAddress,\n  publicKey: string\n): boolean {\n  return address === publicKey;\n}\n","/**\n * TVA Protocol Type Definitions\n *\n * These types define the core abstractions for the TVA Protocol,\n * bridging EVM and Stellar/Soroban concepts.\n */\n\n// ============================================================================\n// Network Configuration\n// ============================================================================\n\nexport type NetworkType = 'testnet' | 'mainnet' | 'local';\n\nexport interface NetworkConfig {\n  /** Network identifier */\n  type: NetworkType;\n  /** TVA RPC endpoint URL */\n  rpcUrl: string;\n  /** Stellar Horizon URL */\n  horizonUrl: string;\n  /** Stellar Soroban RPC URL */\n  sorobanRpcUrl: string;\n  /** Network passphrase for Stellar */\n  networkPassphrase: string;\n  /** Chain ID for EVM compatibility */\n  chainId: number;\n  /** Native currency symbol (XLM) */\n  nativeCurrency: {\n    name: string;\n    symbol: string;\n    decimals: number;\n  };\n}\n\nexport const NETWORKS: Record<NetworkType, NetworkConfig> = {\n  testnet: {\n    type: 'testnet',\n    rpcUrl: 'https://rpc.testnet.tva-protocol.io',\n    horizonUrl: 'https://horizon-testnet.stellar.org',\n    sorobanRpcUrl: 'https://soroban-testnet.stellar.org',\n    networkPassphrase: 'Test SDF Network ; September 2015',\n    chainId: 0x544541, // \"TVA\" in hex (test)\n    nativeCurrency: {\n      name: 'Stellar Lumens',\n      symbol: 'XLM',\n      decimals: 7,\n    },\n  },\n  mainnet: {\n    type: 'mainnet',\n    rpcUrl: 'https://rpc.tva-protocol.io',\n    horizonUrl: 'https://horizon.stellar.org',\n    sorobanRpcUrl: 'https://soroban.stellar.org',\n    networkPassphrase: 'Public Global Stellar Network ; September 2015',\n    chainId: 0x545641, // \"TVA\" in hex\n    nativeCurrency: {\n      name: 'Stellar Lumens',\n      symbol: 'XLM',\n      decimals: 7,\n    },\n  },\n  local: {\n    type: 'local',\n    rpcUrl: 'http://localhost:8545',\n    horizonUrl: 'http://localhost:8000',\n    sorobanRpcUrl: 'http://localhost:8001',\n    networkPassphrase: 'Standalone Network ; February 2017',\n    chainId: 0x545600, // \"TV\" + 0x00\n    nativeCurrency: {\n      name: 'Stellar Lumens',\n      symbol: 'XLM',\n      decimals: 7,\n    },\n  },\n};\n\n// ============================================================================\n// Address Types\n// ============================================================================\n\n/** 20-byte EVM-compatible address (hex string with 0x prefix) */\nexport type EvmAddress = `0x${string}`;\n\n/** 56-character Stellar G-address (Ed25519 public key) */\nexport type StellarAddress = `G${string}`;\n\n/** Soroban contract ID (C-address, 56 characters) */\nexport type SorobanContractId = `C${string}`;\n\n/** Generic address that could be EVM or Stellar format */\nexport type Address = EvmAddress | StellarAddress | SorobanContractId;\n\n/** Mapping between EVM and Stellar addresses */\nexport interface AddressMapping {\n  evmAddress: EvmAddress;\n  stellarAddress: StellarAddress;\n  registeredAt: number; // ledger sequence\n}\n\n// ============================================================================\n// Transaction Types\n// ============================================================================\n\nexport interface EvmTransaction {\n  from: EvmAddress;\n  to?: EvmAddress; // undefined for contract deployment\n  value: bigint;\n  data: string;\n  nonce: number;\n  gasLimit: bigint;\n  gasPrice: bigint;\n  chainId: number;\n}\n\nexport interface EvmTransactionReceipt {\n  transactionHash: string;\n  transactionIndex: number;\n  blockHash: string;\n  blockNumber: number;\n  from: EvmAddress;\n  to: EvmAddress | null;\n  contractAddress: EvmAddress | null;\n  cumulativeGasUsed: bigint;\n  gasUsed: bigint;\n  status: 0 | 1;\n  logs: EvmLog[];\n}\n\nexport interface EvmLog {\n  address: EvmAddress;\n  topics: string[];\n  data: string;\n  blockNumber: number;\n  transactionHash: string;\n  transactionIndex: number;\n  blockHash: string;\n  logIndex: number;\n  removed: boolean;\n}\n\nexport interface EvmBlock {\n  number: number;\n  hash: string;\n  parentHash: string;\n  timestamp: number;\n  miner: EvmAddress;\n  difficulty: bigint;\n  totalDifficulty: bigint;\n  gasLimit: bigint;\n  gasUsed: bigint;\n  transactions: string[];\n  transactionsRoot: string;\n  stateRoot: string;\n  receiptsRoot: string;\n  logsBloom: string;\n  nonce: string;\n  extraData: string;\n}\n\n// ============================================================================\n// Compilation Types\n// ============================================================================\n\nexport interface CompilerInput {\n  /** Solidity source code */\n  source: string;\n  /** Contract file name */\n  fileName: string;\n  /** Compiler optimization settings */\n  optimization?: {\n    enabled: boolean;\n    runs?: number;\n  };\n}\n\nexport interface CompilerOutput {\n  /** Compiled WASM binary (base64 encoded) */\n  wasm: string;\n  /** Contract ABI in JSON format */\n  abi: ContractABI;\n  /** Soroban contract spec entries */\n  spec: SorobanSpec[];\n  /** Compilation warnings */\n  warnings: string[];\n  /** Source map for debugging */\n  sourceMap?: string;\n}\n\nexport interface ContractABI {\n  /** Contract name */\n  name: string;\n  /** ABI entries */\n  functions: ABIFunction[];\n  events: ABIEvent[];\n  errors: ABIError[];\n}\n\nexport interface ABIFunction {\n  name: string;\n  inputs: ABIParameter[];\n  outputs: ABIParameter[];\n  stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';\n  type: 'function' | 'constructor' | 'fallback' | 'receive';\n}\n\nexport interface ABIEvent {\n  name: string;\n  inputs: ABIEventParameter[];\n  anonymous: boolean;\n}\n\nexport interface ABIParameter {\n  name: string;\n  type: string;\n  internalType?: string;\n  components?: ABIParameter[];\n}\n\nexport interface ABIEventParameter extends ABIParameter {\n  indexed: boolean;\n}\n\nexport interface ABIError {\n  name: string;\n  inputs: ABIParameter[];\n}\n\nexport interface SorobanSpec {\n  type: 'function' | 'struct' | 'union' | 'enum' | 'error';\n  name: string;\n  doc?: string;\n  inputs?: { name: string; type: ScValType }[];\n  outputs?: ScValType[];\n}\n\n// ============================================================================\n// Soroban-Specific Types\n// ============================================================================\n\nexport type ScValType =\n  | 'bool'\n  | 'void'\n  | 'error'\n  | 'u32'\n  | 'i32'\n  | 'u64'\n  | 'i64'\n  | 'timepoint'\n  | 'duration'\n  | 'u128'\n  | 'i128'\n  | 'u256'\n  | 'i256'\n  | 'bytes'\n  | 'string'\n  | 'symbol'\n  | 'address'\n  | { vec: ScValType }\n  | { map: { key: ScValType; value: ScValType } }\n  | { option: ScValType }\n  | { result: { ok: ScValType; err: ScValType } }\n  | { tuple: ScValType[] }\n  | { bytesN: number }\n  | { struct: string }\n  | { union: string }\n  | { enum: string };\n\nexport type StorageType = 'temporary' | 'instance' | 'persistent';\n\nexport interface StorageEntry {\n  key: string;\n  value: unknown;\n  type: StorageType;\n  ttl: number; // ledger sequence when entry expires\n}\n\n// ============================================================================\n// Contract Interaction Types\n// ============================================================================\n\nexport interface DeploymentConfig {\n  /** Compiled WASM binary (base64) */\n  wasm: string;\n  /** Constructor arguments */\n  constructorArgs?: unknown[];\n  /** Initial salt for address derivation */\n  salt?: string;\n  /** Network to deploy to */\n  network: NetworkType;\n}\n\nexport interface DeploymentResult {\n  /** Soroban contract ID */\n  contractId: SorobanContractId;\n  /** EVM-compatible contract address */\n  evmAddress: EvmAddress;\n  /** Deployment transaction hash (Stellar format) */\n  stellarTxHash: string;\n  /** Deployment transaction hash (EVM format) */\n  evmTxHash: string;\n  /** Ledger sequence of deployment */\n  ledgerSequence: number;\n}\n\nexport interface ContractCallConfig {\n  /** Contract address (EVM or Soroban format) */\n  contractAddress: Address;\n  /** Function name to call */\n  functionName: string;\n  /** Function arguments */\n  args?: unknown[];\n  /** Caller address */\n  from?: Address;\n}\n\nexport interface ContractCallResult<T = unknown> {\n  /** Return value from the contract */\n  result: T;\n  /** Gas/resource consumption */\n  gasUsed: bigint;\n  /** Events emitted during call */\n  events: EvmLog[];\n  /** Whether the call was a simulation (view) or on-chain */\n  simulated: boolean;\n}\n\n// ============================================================================\n// Wallet Types\n// ============================================================================\n\nexport interface KeyPair {\n  /** secp256k1 private key for EVM signing */\n  evmPrivateKey: string;\n  /** secp256k1 public key (uncompressed, 65 bytes) */\n  evmPublicKey: string;\n  /** Ed25519 secret key for Stellar signing */\n  stellarSecretKey: string;\n  /** Ed25519 public key for Stellar */\n  stellarPublicKey: string;\n}\n\nexport interface Account {\n  /** EVM-format address */\n  evmAddress: EvmAddress;\n  /** Stellar G-address */\n  stellarAddress: StellarAddress;\n  /** Whether this account is registered in the AccountRegistry */\n  isRegistered: boolean;\n  /** Account sequence number (Stellar) */\n  sequenceNumber?: string;\n  /** Account nonce (EVM) */\n  nonce?: number;\n}\n\nexport interface Balance {\n  /** Native XLM balance (in stroops, 1 XLM = 10^7 stroops) */\n  xlm: bigint;\n  /** Native XLM balance formatted (7 decimals) */\n  xlmFormatted: string;\n  /** Token balances keyed by contract address */\n  tokens: Map<Address, TokenBalance>;\n}\n\nexport interface TokenBalance {\n  /** Token contract address */\n  address: Address;\n  /** Token symbol */\n  symbol: string;\n  /** Token decimals */\n  decimals: number;\n  /** Raw balance */\n  balance: bigint;\n  /** Formatted balance */\n  balanceFormatted: string;\n}\n\n// ============================================================================\n// Error Types\n// ============================================================================\n\nexport class TVAError extends Error {\n  constructor(\n    message: string,\n    public code: TVAErrorCode,\n    public details?: Record<string, unknown>\n  ) {\n    super(message);\n    this.name = 'TVAError';\n  }\n}\n\nexport enum TVAErrorCode {\n  // Compilation errors (1xxx)\n  COMPILATION_FAILED = 1001,\n  SOLANG_NOT_FOUND = 1002,\n  INVALID_SOURCE = 1003,\n\n  // Network errors (2xxx)\n  NETWORK_ERROR = 2001,\n  RPC_ERROR = 2002,\n  TIMEOUT = 2003,\n\n  // Transaction errors (3xxx)\n  TRANSACTION_FAILED = 3001,\n  INSUFFICIENT_BALANCE = 3002,\n  INVALID_NONCE = 3003,\n  GAS_ESTIMATION_FAILED = 3004,\n\n  // Contract errors (4xxx)\n  CONTRACT_NOT_FOUND = 4001,\n  CONTRACT_REVERT = 4002,\n  INVALID_ARGUMENTS = 4003,\n\n  // Account errors (5xxx)\n  ACCOUNT_NOT_FOUND = 5001,\n  ACCOUNT_NOT_REGISTERED = 5002,\n  INVALID_SIGNATURE = 5003,\n\n  // Storage errors (6xxx)\n  STATE_ARCHIVED = 6001,\n  TTL_EXPIRED = 6002,\n  RESTORATION_FAILED = 6003,\n}\n","/**\n * TVA Protocol Transaction Signer\n *\n * Handles signing for both EVM-format and Stellar-format transactions.\n * This is critical for the TVA dual-key architecture where:\n * - Users sign with their EVM wallet (MetaMask)\n * - The signed transaction is translated and re-signed for Stellar submission\n */\n\nimport {\n  Keypair,\n  Transaction,\n  xdr,\n} from '@stellar/stellar-sdk';\nimport { keccak_256 } from '@noble/hashes/sha3';\nimport * as secp256k1 from '@noble/secp256k1';\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport type {\n  KeyPair,\n  EvmTransaction,\n  EvmAddress,\n  NetworkType,\n  NetworkConfig,\n} from '../types/index.js';\nimport { NETWORKS } from '../types/index.js';\nimport { getEvmAddress } from './keys.js';\n\n// RFC6979 deterministic k generation for secp256k1 signing\nsecp256k1.etc.hmacSha256Sync = (k, ...m) =>\n  hmac(sha256, k, secp256k1.etc.concatBytes(...m));\n\n/**\n * EVM Transaction Signer\n * Signs transactions using secp256k1 (Ethereum-compatible)\n */\nexport class EvmSigner {\n  private privateKey: Uint8Array;\n  public readonly address: EvmAddress;\n\n  constructor(keyPair: KeyPair) {\n    this.privateKey = Buffer.from(\n      keyPair.evmPrivateKey.replace(/^0x/, ''),\n      'hex'\n    );\n    this.address = getEvmAddress(keyPair);\n  }\n\n  /**\n   * Signs a message hash using secp256k1\n   */\n  signHash(hash: Uint8Array): { r: string; s: string; v: number } {\n    const signature = secp256k1.sign(hash, this.privateKey);\n    const r = signature.r.toString(16).padStart(64, '0');\n    const s = signature.s.toString(16).padStart(64, '0');\n\n    // Calculate recovery id (v)\n    // For EIP-155 transactions: v = chainId * 2 + 35 + recovery_id\n    // For legacy: v = 27 + recovery_id\n    const v = signature.recovery + 27;\n\n    return { r: `0x${r}`, s: `0x${s}`, v };\n  }\n\n  /**\n   * Signs a personal message (EIP-191)\n   */\n  signMessage(message: string): string {\n    const messageBytes = new TextEncoder().encode(message);\n    const prefix = new TextEncoder().encode(\n      `\\x19Ethereum Signed Message:\\n${messageBytes.length}`\n    );\n    const prefixedMessage = new Uint8Array([...prefix, ...messageBytes]);\n    const hash = keccak_256(prefixedMessage);\n\n    const { r, s, v } = this.signHash(hash);\n    return `${r}${s.slice(2)}${v.toString(16).padStart(2, '0')}`;\n  }\n\n  /**\n   * Signs typed data (EIP-712)\n   */\n  signTypedData(\n    domain: Record<string, unknown>,\n    types: Record<string, Array<{ name: string; type: string }>>,\n    value: Record<string, unknown>\n  ): string {\n    // Simplified EIP-712 implementation\n    // In production, use a full implementation from ethers.js\n    const domainSeparator = this.hashStruct('EIP712Domain', domain, {\n      EIP712Domain: [\n        { name: 'name', type: 'string' },\n        { name: 'version', type: 'string' },\n        { name: 'chainId', type: 'uint256' },\n        { name: 'verifyingContract', type: 'address' },\n      ],\n    });\n\n    const primaryType = Object.keys(types).find((t) => t !== 'EIP712Domain');\n    if (!primaryType) {\n      throw new Error('No primary type found');\n    }\n\n    const structHash = this.hashStruct(primaryType, value, types);\n\n    const messageHash = keccak_256(\n      new Uint8Array([0x19, 0x01, ...domainSeparator, ...structHash])\n    );\n\n    const { r, s, v } = this.signHash(messageHash);\n    return `${r}${s.slice(2)}${v.toString(16).padStart(2, '0')}`;\n  }\n\n  private hashStruct(\n    typeName: string,\n    data: Record<string, unknown>,\n    types: Record<string, Array<{ name: string; type: string }>>\n  ): Uint8Array {\n    const typeHash = keccak_256(\n      new TextEncoder().encode(this.encodeType(typeName, types))\n    );\n    const encodedData = this.encodeData(typeName, data, types);\n    return keccak_256(new Uint8Array([...typeHash, ...encodedData]));\n  }\n\n  private encodeType(\n    primaryType: string,\n    types: Record<string, Array<{ name: string; type: string }>>\n  ): string {\n    const fields = types[primaryType];\n    if (!fields) {\n      return primaryType;\n    }\n\n    const fieldDefs = fields.map((f) => `${f.type} ${f.name}`).join(',');\n    return `${primaryType}(${fieldDefs})`;\n  }\n\n  private encodeData(\n    typeName: string,\n    data: Record<string, unknown>,\n    types: Record<string, Array<{ name: string; type: string }>>\n  ): Uint8Array {\n    const fields = types[typeName];\n    if (!fields) {\n      throw new Error(`Unknown type: ${typeName}`);\n    }\n\n    const parts: Uint8Array[] = [];\n\n    for (const field of fields) {\n      const value = data[field.name];\n      parts.push(this.encodeValue(field.type, value, types));\n    }\n\n    return new Uint8Array(parts.flatMap((p) => [...p]));\n  }\n\n  private encodeValue(\n    type: string,\n    value: unknown,\n    types: Record<string, Array<{ name: string; type: string }>>\n  ): Uint8Array {\n    if (type === 'string') {\n      return keccak_256(new TextEncoder().encode(value as string));\n    }\n\n    if (type === 'bytes') {\n      const bytes = Buffer.from((value as string).replace(/^0x/, ''), 'hex');\n      return keccak_256(bytes);\n    }\n\n    if (type === 'address') {\n      const addr = (value as string).replace(/^0x/, '').toLowerCase();\n      const padded = new Uint8Array(32);\n      const addrBytes = Buffer.from(addr, 'hex');\n      padded.set(addrBytes, 32 - addrBytes.length);\n      return padded;\n    }\n\n    if (type.startsWith('uint') || type.startsWith('int')) {\n      const num = BigInt(value as string | number | bigint);\n      const bytes = new Uint8Array(32);\n      let val = num;\n      for (let i = 31; i >= 0; i--) {\n        bytes[i] = Number(val & BigInt(0xff));\n        val = val >> BigInt(8);\n      }\n      return bytes;\n    }\n\n    if (type === 'bool') {\n      const bytes = new Uint8Array(32);\n      bytes[31] = value ? 1 : 0;\n      return bytes;\n    }\n\n    if (types[type]) {\n      return this.hashStruct(type, value as Record<string, unknown>, types);\n    }\n\n    throw new Error(`Unsupported type: ${type}`);\n  }\n\n  /**\n   * Signs an EVM transaction and returns the signed raw transaction\n   */\n  signTransaction(tx: EvmTransaction): string {\n    // Encode transaction for signing (RLP encoding)\n    const encodedTx = this.rlpEncodeTransaction(tx);\n    const hash = keccak_256(encodedTx);\n\n    const signature = this.signHash(hash);\n\n    // Calculate v with EIP-155 chain ID\n    const v = tx.chainId * 2 + 35 + (signature.v - 27);\n\n    // Encode signed transaction\n    return this.rlpEncodeSignedTransaction(tx, {\n      r: signature.r,\n      s: signature.s,\n      v,\n    });\n  }\n\n  private rlpEncodeTransaction(tx: EvmTransaction): Uint8Array {\n    // Simplified RLP encoding for EIP-155 transactions\n    // Format: [nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0]\n    const items: (Uint8Array | string | number | bigint | null)[] = [\n      tx.nonce,\n      tx.gasPrice,\n      tx.gasLimit,\n      tx.to || '',\n      tx.value,\n      tx.data,\n      tx.chainId,\n      0,\n      0,\n    ];\n\n    return this.rlpEncode(items);\n  }\n\n  private rlpEncodeSignedTransaction(\n    tx: EvmTransaction,\n    sig: { r: string; s: string; v: number }\n  ): string {\n    const items: (Uint8Array | string | number | bigint | null)[] = [\n      tx.nonce,\n      tx.gasPrice,\n      tx.gasLimit,\n      tx.to || '',\n      tx.value,\n      tx.data,\n      sig.v,\n      sig.r,\n      sig.s,\n    ];\n\n    const encoded = this.rlpEncode(items);\n    return '0x' + Buffer.from(encoded).toString('hex');\n  }\n\n  private rlpEncode(\n    input: (Uint8Array | string | number | bigint | null)[] | Uint8Array | string | number | bigint | null\n  ): Uint8Array {\n    if (Array.isArray(input)) {\n      const encodedItems = input.map((item) => this.rlpEncode(item));\n      const totalLength = encodedItems.reduce((sum, item) => sum + item.length, 0);\n      const flatItems = encodedItems.flatMap((item) => Array.from(item));\n\n      if (totalLength < 56) {\n        return new Uint8Array([0xc0 + totalLength, ...flatItems]);\n      } else {\n        const lengthBytes = this.encodeBigEndian(totalLength);\n        return new Uint8Array([\n          0xf7 + lengthBytes.length,\n          ...Array.from(lengthBytes),\n          ...flatItems,\n        ]);\n      }\n    }\n\n    const bytes = this.toBytes(input);\n\n    if (bytes.length === 1 && bytes[0] < 0x80) {\n      return bytes;\n    }\n\n    if (bytes.length < 56) {\n      return new Uint8Array([0x80 + bytes.length, ...Array.from(bytes)]);\n    }\n\n    const lengthBytes = this.encodeBigEndian(bytes.length);\n    return new Uint8Array([0xb7 + lengthBytes.length, ...Array.from(lengthBytes), ...Array.from(bytes)]);\n  }\n\n  private toBytes(\n    input: Uint8Array | string | number | bigint | null\n  ): Uint8Array {\n    if (input === null || input === '' || input === 0 || input === BigInt(0)) {\n      return new Uint8Array(0);\n    }\n\n    if (input instanceof Uint8Array) {\n      return input;\n    }\n\n    if (typeof input === 'string') {\n      if (input.startsWith('0x')) {\n        const hex = input.slice(2);\n        if (hex.length === 0) {\n          return new Uint8Array(0);\n        }\n        return Buffer.from(hex.padStart(hex.length + (hex.length % 2), '0'), 'hex');\n      }\n      return new TextEncoder().encode(input);\n    }\n\n    if (typeof input === 'number' || typeof input === 'bigint') {\n      return this.encodeBigEndian(input);\n    }\n\n    throw new Error(`Cannot encode: ${input}`);\n  }\n\n  private encodeBigEndian(value: number | bigint): Uint8Array {\n    if (value === 0 || value === BigInt(0)) {\n      return new Uint8Array(0);\n    }\n\n    const bytes: number[] = [];\n    let v = BigInt(value);\n\n    while (v > 0) {\n      bytes.unshift(Number(v & BigInt(0xff)));\n      v = v >> BigInt(8);\n    }\n\n    return new Uint8Array(bytes);\n  }\n}\n\n/**\n * Stellar Transaction Signer\n * Signs transactions using Ed25519 (Stellar-compatible)\n */\nexport class StellarSigner {\n  private keypair: Keypair;\n  public readonly publicKey: string;\n\n  constructor(keyPair: KeyPair) {\n    this.keypair = Keypair.fromSecret(keyPair.stellarSecretKey);\n    this.publicKey = this.keypair.publicKey();\n  }\n\n  /**\n   * Signs a Stellar transaction\n   */\n  signTransaction(\n    transaction: Transaction,\n    _networkPassphrase?: string\n  ): Transaction {\n    transaction.sign(this.keypair);\n    return transaction;\n  }\n\n  /**\n   * Signs arbitrary data\n   */\n  signData(data: Uint8Array): Uint8Array {\n    return this.keypair.sign(Buffer.from(data));\n  }\n\n  /**\n   * Verifies a signature\n   */\n  verifySignature(data: Uint8Array, signature: Uint8Array): boolean {\n    return this.keypair.verify(Buffer.from(data), Buffer.from(signature));\n  }\n\n  /**\n   * Signs a Soroban authorization entry\n   */\n  signAuthEntry(\n    entry: xdr.SorobanAuthorizationEntry,\n    networkPassphrase: string,\n    validUntilLedger: number\n  ): xdr.SorobanAuthorizationEntry {\n    // Clone the entry to avoid mutation\n    const signedEntry = xdr.SorobanAuthorizationEntry.fromXDR(entry.toXDR());\n\n    // Get the credentials\n    const credentials = signedEntry.credentials();\n\n    if (credentials.switch().value === 0) {\n      // Source account credentials - no signature needed\n      return signedEntry;\n    }\n\n    // Address credentials - need to sign\n    const addressCredentials = credentials.address();\n\n    // Create the preimage for signing\n    const preimage = xdr.HashIdPreimage.envelopeTypeSorobanAuthorization(\n      new xdr.HashIdPreimageSorobanAuthorization({\n        networkId: Buffer.from(sha256(new TextEncoder().encode(networkPassphrase))),\n        nonce: addressCredentials.nonce(),\n        signatureExpirationLedger: validUntilLedger,\n        invocation: signedEntry.rootInvocation(),\n      })\n    );\n\n    const preimageHash = sha256(preimage.toXDR());\n    const signature = this.keypair.sign(Buffer.from(preimageHash));\n\n    // Set the signature\n    const newCredentials = new xdr.SorobanAddressCredentials({\n      address: addressCredentials.address(),\n      nonce: addressCredentials.nonce(),\n      signatureExpirationLedger: validUntilLedger,\n      signature: xdr.ScVal.scvVec([\n        xdr.ScVal.scvMap([\n          new xdr.ScMapEntry({\n            key: xdr.ScVal.scvSymbol('public_key'),\n            val: xdr.ScVal.scvBytes(this.keypair.rawPublicKey()),\n          }),\n          new xdr.ScMapEntry({\n            key: xdr.ScVal.scvSymbol('signature'),\n            val: xdr.ScVal.scvBytes(signature),\n          }),\n        ]),\n      ]),\n    });\n\n    signedEntry.credentials(xdr.SorobanCredentials.sorobanCredentialsAddress(newCredentials));\n\n    return signedEntry;\n  }\n}\n\n/**\n * Combined TVA Signer that handles both EVM and Stellar signing\n */\nexport class TVASigner {\n  public readonly evmSigner: EvmSigner;\n  public readonly stellarSigner: StellarSigner;\n  public readonly keyPair: KeyPair;\n  public readonly network: NetworkConfig;\n\n  constructor(keyPair: KeyPair, network: NetworkType = 'testnet') {\n    this.keyPair = keyPair;\n    this.network = NETWORKS[network];\n    this.evmSigner = new EvmSigner(keyPair);\n    this.stellarSigner = new StellarSigner(keyPair);\n  }\n\n  get evmAddress(): EvmAddress {\n    return this.evmSigner.address;\n  }\n\n  get stellarAddress(): string {\n    return this.stellarSigner.publicKey;\n  }\n\n  /**\n   * Signs an EVM-format transaction\n   */\n  signEvmTransaction(tx: EvmTransaction): string {\n    return this.evmSigner.signTransaction(tx);\n  }\n\n  /**\n   * Signs a Stellar transaction\n   */\n  signStellarTransaction(transaction: Transaction): Transaction {\n    return this.stellarSigner.signTransaction(\n      transaction,\n      this.network.networkPassphrase\n    );\n  }\n\n  /**\n   * Signs a personal message (for wallet connect / dapp signatures)\n   */\n  signMessage(message: string): string {\n    return this.evmSigner.signMessage(message);\n  }\n}\n"]}